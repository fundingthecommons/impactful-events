// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    // NOTE: When using mysql or sqlserver, uncomment the @db.Text annotations in model Account below
    // Further reading:
    // https://next-auth.js.org/adapters/prisma#create-the-prisma-schema
    // https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#string
    url      = env("DATABASE_URL")
}

model Post {
    id        Int      @id @default(autoincrement())
    name      String
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    createdBy   User   @relation(fields: [createdById], references: [id])
    createdById String

    @@index([name])
}

// Necessary for Next auth
model Account {
  id                       String  @id @default(cuid())
  userId                   String
  type                     String
  provider                 String
  providerAccountId        String
  refresh_token            String?
  access_token             String?
  expires_at               Int?
  token_type               String?
  scope                    String?
  id_token                 String?
  session_state            String?
  refresh_token_expires_in Int?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
    id           String   @id @default(cuid())
    sessionToken String   @unique
    userId       String
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  password      String?   // Hashed password for email/password authentication
  role          String?   @default("user") // Add simple role field
  isAIReviewer  Boolean   @default(false) // Identifies AI reviewers like Elinor Ostrom
  accounts      Account[]
  sessions      Session[]
  posts         Post[]

  teamMemberships TeamMembership[]
  mentorSessions  MentorshipSession[] @relation("MentorSessions")
  createdHackathons Hackathon[]       @relation("HackathonCreatedBy")
  createdProjects Project[]           @relation("ProjectCreatedBy")
  judgedScores   Score[]              @relation("JudgedBy")
  judge           Judge?
  userRoles       UserRole[]
  userGlobalRoles UserGlobalRole[] // Keep for backward compatibility but use role field primarily
  createdEvents   Event[]              @relation("EventsCreatedBy")
  applications    Application[]
  
  // Evaluation system relations
  reviewerAssignments    ReviewerAssignment[]     @relation("ReviewerAssignments")
  applicationEvaluations ApplicationEvaluation[]  @relation("ApplicationEvaluations")
  consensusDecisions     ReviewConsensus[]        @relation("ConsensusDecisions")
  
  // Reviewer competency relations
  reviewerCompetencies   ReviewerCompetency[]     @relation("ReviewerCompetencies")
  assignedCompetencies   ReviewerCompetency[]     @relation("AssignedCompetencies")
  
  // Internal admin fields for user management
  adminNotes          String?   @db.Text  // Internal admin notes about this user
  adminWorkExperience String?   @db.Text  // LinkedIn work experience copy
  adminLabels         String[]             // Array: 'Entrepreneur', 'Developer', 'Designer', 'Researcher'
  adminUpdatedBy      String?              // Admin who last updated these fields
  adminUpdatedAt      DateTime?            // When admin fields were last updated
  
  // Profile system relations
  profile        UserProfile?
  profileSyncs   ProfileSync[]
  
  // Admin update relations
  adminUpdater    User?     @relation("AdminUpdates", fields: [adminUpdatedBy], references: [id])
  adminUpdates    User[]    @relation("AdminUpdates")
  
  // Telegram authentication relation
  telegramAuth         TelegramAuth?
  telegramAuthSessions TelegramAuthSession[]
  
  // Skills system relation
  userSkills           UserSkills[]         @relation("UserSkills")
}

model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
}

model Event {
  id          String   @id @default(cuid())
  name        String
  description String?
  startDate   DateTime
  endDate     DateTime
  location    String?
  type        String   // e.g., "HACKATHON", "DINNER", "CONFERENCE"
  isOnline    Boolean  @default(true)

  createdBy   User     @relation("EventsCreatedBy", fields: [createdById], references: [id])
  createdById String

  hackathon   Hackathon?
  // Add other event-specific relations as needed

  userRoles   UserRole[]
  sponsors    EventSponsor[]
  applications Application[]
  applicationQuestions ApplicationQuestion[]
  communications Communication[]  // Communications related to this event
  emails      Email[]  // Legacy: Emails related to this event (for backward compatibility)
  invitations Invitation[]  // Invitations for this event
}

model Hackathon {
  id          String   @id @default(cuid())
  name        String
  description String
  startDate   DateTime
  endDate     DateTime
  location    String?
  isOnline    Boolean  @default(true)

  createdBy   User     @relation("HackathonCreatedBy", fields: [createdById], references: [id])
  createdById String

  teams       Team[]
  tracks      Track[]
  announcements Announcement[]

  event Event? @relation(fields: [eventId], references: [id])
  eventId String? @unique
}

model Track {
  id          String   @id @default(cuid())
  name        String
  description String?
  hackathon   Hackathon @relation(fields: [hackathonId], references: [id])
  hackathonId String

  projects    Project[]
}

model Team {
  id          String   @id @default(cuid())
  name        String
  hackathon   Hackathon @relation(fields: [hackathonId], references: [id])
  hackathonId String

  members     TeamMembership[]
  project     Project?
  mentorshipSessions MentorshipSession[]
}

model TeamMembership {
  id      String @id @default(cuid())
  user    User   @relation(fields: [userId], references: [id])
  userId  String
  team    Team   @relation(fields: [teamId], references: [id])
  teamId  String

  joinedAt DateTime @default(now())

  @@unique([userId, teamId])
}

model Project {
  id          String   @id @default(cuid())
  title       String
  description String?
  repoUrl     String?
  demoUrl     String?
  videoUrl    String?
  submissionDate DateTime?

  team        Team     @relation(fields: [teamId], references: [id])
  teamId      String   @unique

  track       Track?   @relation(fields: [trackId], references: [id])
  trackId     String?

  createdBy   User     @relation("ProjectCreatedBy", fields: [createdById], references: [id])
  createdById String

  scores      Score[]
}

model Judge {
  id     String @id @default(cuid())
  user   User   @relation(fields: [userId], references: [id])
  userId String @unique

  criteria JudgingCriteria[]
}

model JudgingCriteria {
  id        String @id @default(cuid())
  name      String
  weight    Float  @default(1.0)
  judge     Judge  @relation(fields: [judgeId], references: [id])
  judgeId   String
}

model Score {
  id         String    @id @default(cuid())
  value      Float
  notes      String?
  project    Project   @relation(fields: [projectId], references: [id])
  projectId  String
  judge      User      @relation("JudgedBy", fields: [judgeId], references: [id])
  judgeId    String
  criteria   String
}

model MentorshipSession {
  id        String   @id @default(cuid())
  mentor    User     @relation("MentorSessions", fields: [mentorId], references: [id])
  mentorId  String
  team      Team     @relation(fields: [teamId], references: [id])
  teamId    String
  scheduledAt DateTime
  durationMinutes Int
  notes     String?
}

model Announcement {
  id          String   @id @default(cuid())
  hackathon   Hackathon @relation(fields: [hackathonId], references: [id])
  hackathonId String
  message     String
  publishedAt DateTime @default(now())
}

model Role {
  id        String   @id @default(cuid())
  name      String  
  userRoles UserRole[]
  invitations Invitation[]  // Invitations for this role

  @@unique([name])
}

model UserRole {
  id      String   @id @default(cuid())
  user    User     @relation(fields: [userId], references: [id])
  userId  String
  event   Event    @relation(fields: [eventId], references: [id])
  eventId String
  role    Role     @relation(fields: [roleId], references: [id])
  roleId  String

  @@unique([userId, eventId, roleId])
}

model Sponsor {
  id          String         @id @default(cuid())
  name        String         @unique
  websiteUrl  String?
  logoUrl     String?
  events      EventSponsor[]
  contacts    Contact[]
  categories  SponsorCategory[]
  geckoCoin   GeckoCoin?
}

model EventSponsor {
  id        String   @id @default(cuid())
  event     Event    @relation(fields: [eventId], references: [id])
  eventId   String
  sponsor   Sponsor  @relation(fields: [sponsorId], references: [id])
  sponsorId String
  qualified Boolean  @default(false)

  visitRequests SponsorVisitRequest[]
  deliverables  SponsorDeliverable[]

  @@unique([eventId, sponsorId])
}

model Contact {
  id        String @id @default(cuid())
  firstName String
  lastName  String
  email     String @unique
  sponsor   Sponsor? @relation(fields: [sponsorId], references: [id])
  sponsorId String?
  linkedIn  String?
  telegram  String?
  twitter   String?
  github   String?
  phone     String?
}

model GeckoCoin {
  id                              String   @id @default(cuid())
  geckoId                         String   @unique // CoinGecko's unique ID
  symbol                          String
  name                            String
  image                           String?
  currentPrice                    Float?
  marketCap                       Float?
  marketCapRank                   Int?
  fullyDilutedValuation           Float?
  totalVolume                     Float?
  high24h                         Float?
  low24h                          Float?
  priceChange24h                  Float?
  priceChangePercentage24h        Float?
  marketCapChange24h              Float?
  marketCapChangePercentage24h    Float?
  circulatingSupply               Float?
  totalSupply                     Float?
  maxSupply                       Float?
  ath                             Float?
  athChangePercentage             Float?
  athDate                         DateTime?
  atl                             Float?
  atlChangePercentage             Float?
  atlDate                         DateTime?
  roiTimes                        Float?
  roiCurrency                     String?
  roiPercentage                   Float?
  lastUpdated                     DateTime?
  createdAt                       DateTime @default(now())
  updatedAt                       DateTime @updatedAt

  sponsorId                       String? @unique
  sponsor                         Sponsor? @relation(fields: [sponsorId], references: [id])

  categories                      CategoryGeckoCoin[]
}

model Category {
  id        String   @id @default(cuid())
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sponsors  SponsorCategory[]
  geckoCoins CategoryGeckoCoin[]
}

model SponsorCategory {
  id         String   @id @default(cuid())
  sponsor    Sponsor  @relation(fields: [sponsorId], references: [id])
  sponsorId  String
  category   Category @relation(fields: [categoryId], references: [id])
  categoryId String
  createdAt  DateTime @default(now())

  @@unique([sponsorId, categoryId])
}

model CategoryGeckoCoin {
  id         String    @id @default(cuid())
  category   Category  @relation(fields: [categoryId], references: [id])
  categoryId String
  geckoCoin  GeckoCoin @relation(fields: [geckoId], references: [id])
  geckoId    String
  createdAt  DateTime  @default(now())

  @@unique([categoryId, geckoId])
}

model GlobalRole {
  id             String @id @default(cuid())
  name           String @unique
  description    String?
  permissions    String[] // JSON array of permissions like ["events:read", "contacts:read", "imports:write"]
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  userGlobalRoles UserGlobalRole[]
}

model UserGlobalRole {
  id           String @id @default(cuid())
  user         User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId       String
  globalRole   GlobalRole @relation(fields: [globalRoleId], references: [id], onDelete: Cascade)
  globalRoleId String
  assignedAt   DateTime @default(now())
  assignedBy   String? // Optional: track who assigned the role

  @@unique([userId, globalRoleId])
}

// Application System Models

enum ApplicationStatus {
  DRAFT
  SUBMITTED
  UNDER_REVIEW
  ACCEPTED
  REJECTED
  WAITLISTED
  CANCELLED
}

enum QuestionType {
  TEXT
  TEXTAREA
  EMAIL
  PHONE
  URL
  SELECT
  MULTISELECT
  CHECKBOX
  NUMBER
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  EXPIRED
  CANCELLED
}

enum InvitationType {
  EVENT_ROLE      // For event-specific roles (mentor, sponsor, etc.)
  GLOBAL_ADMIN    // For global admin access
  GLOBAL_STAFF    // For global staff access
}

model Application {
  id            String   @id @default(cuid())
  userId        String?  // Optional initially for legacy data
  eventId       String   // Links to event
  email         String   // For matching legacy submissions
  status        ApplicationStatus @default(DRAFT)
  language      String   @default("en") // User's preferred language
  affiliation   String?  // Organization or company affiliation
  isComplete    Boolean  @default(false) // Tracks if all required fields are filled
  completedAt   DateTime? // When it became complete
  lastIncompleteAt DateTime? // Last time it was incomplete (for notifications)
  submittedAt   DateTime?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // Waitlist management
  waitlistOrder Int?     // Manual override for waitlist position (null = auto-ranked)
  
  // Legacy data tracking
  googleFormId  String?  // If migrated from Google Forms
  notionPageId  String?  // If migrated from Notion Forms
  
  user          User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  event         Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  responses     ApplicationResponse[]
  communications Communication[]  // Communications related to this application
  emails        Email[]  // Legacy: Emails related to this application (for backward compatibility)
  
  // Evaluation system relations
  reviewerAssignments   ReviewerAssignment[]
  evaluations          ApplicationEvaluation[]
  consensus            ReviewConsensus?
  
  // Profile sync relations  
  profileSyncs         ProfileSync[]
  
  // Onboarding relation
  onboarding           ApplicationOnboarding?
  
  @@unique([userId, eventId]) // One application per user per event
  @@index([email])
  @@index([status])
}

model ApplicationQuestion {
  id            String   @id @default(cuid())
  eventId       String   // Questions can be event-specific
  order         Int      // Display order
  questionKey   String   // Unique key for the question (e.g., "full_name", "email")
  questionEn    String   // Question in English
  questionEs    String   // Question in Spanish
  questionType  QuestionType
  required      Boolean  @default(true)
  options       String[] // For multiple choice questions (JSON array)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  event         Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  responses     ApplicationResponse[]
  
  @@unique([eventId, questionKey]) // Unique question per event
  @@index([eventId, order])
}

model ApplicationResponse {
  id            String   @id @default(cuid())
  applicationId String
  questionId    String
  answer        String   // Store answer as text (JSON for complex responses)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  application   Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  question      ApplicationQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)
  
  @@unique([applicationId, questionId])
  @@index([applicationId])
}

// Invitation System Models
model Invitation {
  id          String   @id @default(cuid())
  email       String   // Email to invite
  type        InvitationType @default(EVENT_ROLE) // Type of invitation
  eventId     String?  // Which event they're being invited to (null for global roles)
  roleId      String?  // What event role they'll get (null for global roles)
  globalRole  String?  // Global role for global invitations (admin, staff)
  
  status      InvitationStatus @default(PENDING)
  expiresAt   DateTime
  invitedBy   String   // Admin who sent invitation
  token       String   @unique @default(cuid()) // For invitation links
  
  createdAt   DateTime @default(now())
  acceptedAt  DateTime?
  
  event       Event?   @relation(fields: [eventId], references: [id], onDelete: Cascade)
  role        Role?    @relation(fields: [roleId], references: [id], onDelete: Cascade)
  
  @@unique([email, eventId, roleId]) // Prevent duplicate event role invites
  @@unique([email, type, globalRole]) // Prevent duplicate global role invites
  @@index([email])
  @@index([token])
  @@index([status])
  @@index([type])
}

// Communication System Models
enum CommunicationType {
  EMAIL
  TELEGRAM
  SMS          // Future
  DISCORD      // Future
  WHATSAPP     // Future
}

enum CommunicationStatus {
  DRAFT
  QUEUED
  SENT
  FAILED
  CANCELLED
}

enum CommunicationContentType {
  // Application related
  APPLICATION_SUBMITTED
  APPLICATION_ACCEPTED
  APPLICATION_REJECTED  
  APPLICATION_WAITLISTED
  APPLICATION_UNDER_REVIEW
  APPLICATION_MISSING_INFO
  
  // Invitation related
  INVITATION_EVENT_ROLE
  INVITATION_ADMIN
  
  // General
  GENERAL
  BULK_MESSAGE     // New: For bulk telegram messages
  TEST
  
  // Legacy (for backward compatibility)
  MISSING_INFO    // Deprecated: Use APPLICATION_MISSING_INFO
  STATUS_UPDATE   // Deprecated: Use specific status types
}

// Legacy enums for backward compatibility
enum EmailStatus {
  DRAFT
  QUEUED
  SENT
  FAILED
  CANCELLED
}

enum EmailType {
  // Application related
  APPLICATION_SUBMITTED
  APPLICATION_ACCEPTED
  APPLICATION_REJECTED  
  APPLICATION_WAITLISTED
  APPLICATION_UNDER_REVIEW
  APPLICATION_MISSING_INFO
  
  // Invitation related
  INVITATION_EVENT_ROLE
  INVITATION_ADMIN
  
  // General
  GENERAL
  TEST
  
  // Legacy (for backward compatibility)
  MISSING_INFO    // Deprecated: Use APPLICATION_MISSING_INFO
  STATUS_UPDATE   // Deprecated: Use specific status types
}

model Communication {
  id            String      @id @default(cuid())
  applicationId String?     // Optional: link to specific application  
  eventId       String      // Required: link to event
  
  // Channel-specific recipient fields
  toEmail       String?     // For email communications
  toTelegram    String?     // For telegram (@username or user_id)
  toPhone       String?     // For SMS (future)
  toDiscord     String?     // For Discord (future)
  
  // Channel identification
  channel       CommunicationType @default(EMAIL)
  
  // Content fields (channel-agnostic)
  subject       String?     // Email subject OR Telegram summary
  htmlContent   String?     @db.Text // HTML email content
  textContent   String      @db.Text // Plain text (required for all channels)
  
  // Legacy email-specific fields for backward compatibility
  fromEmail     String?     @default("james@fundingthecommons.io") // Email sender
  
  // Status and type (channel-agnostic)
  type          CommunicationContentType @default(MISSING_INFO)
  status        CommunicationStatus @default(DRAFT)
  
  // Metadata (channel-agnostic)
  missingFields String[]    // JSON array of missing field keys
  createdBy     String      // User ID who created
  sentAt        DateTime?   // When actually sent
  failureReason String?     // Error message if sending failed
  
  // Channel-specific tracking IDs
  postmarkId    String?     // Email: Postmark message ID
  telegramMsgId String?     // Telegram: Message ID from API
  
  // Template tracking (channel-agnostic)
  templateName    String?     // Which template was used
  templateVersion String?     // Template version for tracking
  templateData    Json?       // JSON data used to render
  
  // Engagement tracking (channel-specific)
  openedAt        DateTime?   // Email: when opened
  clickedAt       DateTime?   // Email: when links clicked
  readAt          DateTime?   // Telegram: when read (if available)
  
  // Standard timestamps
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  
  // Relations
  application   Application? @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  event         Event       @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  // Indexes for performance
  @@index([applicationId])
  @@index([eventId]) 
  @@index([status])
  @@index([toEmail])      // Email search
  @@index([toTelegram])   // Telegram search
  @@index([channel])      // Filter by communication type
  @@index([type])         // Filter by content type
}

// Legacy Email model for backward compatibility (will be populated via view or alias)
model Email {
  id            String      @id @default(cuid())
  applicationId String?     // Optional: link to specific application
  eventId       String      // Required: link to event
  toEmail       String      // Recipient email address
  fromEmail     String      @default("james@fundingthecommons.io") // Always send from this for testing
  subject       String      // Email subject line
  htmlContent   String      @db.Text // HTML version of email
  textContent   String?     @db.Text // Plain text version (optional)
  type          EmailType   @default(MISSING_INFO)
  status        EmailStatus @default(DRAFT)
  
  // Metadata
  missingFields String[]    // JSON array of missing field keys (for MISSING_INFO emails)
  createdBy     String      // User ID who created the email
  sentAt        DateTime?   // When email was actually sent
  failureReason String?     // Error message if sending failed
  postmarkId    String?     // Postmark message ID for tracking
  
  // Template tracking
  templateName    String?     // Which template was used (e.g., "application_accepted")
  templateVersion String?     // Template version for tracking changes
  templateData    Json?       // JSON data used to render template
  openedAt        DateTime?   // When email was opened (if tracking enabled)
  clickedAt       DateTime?   // When links were clicked (if tracking enabled)
  
  // Timestamps
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  
  // Relations
  application   Application? @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  event         Event       @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  @@index([applicationId])
  @@index([eventId])
  @@index([status])
  @@index([toEmail])
}

// Sponsor Residency Models
enum VisitType {
  KICKOFF        // Opening week kickoff (1-2 days)
  MENTORSHIP     // Mid-program mentorship visit
  DEMO_DAY       // Final showcase/demo day
  CUSTOM         // Custom dates
}

enum VisitStatus {
  PENDING
  APPROVED
  SCHEDULED
  COMPLETED
  CANCELLED
}

enum DeliverableCategory {
  TECHNICAL      // Technical mentorship & knowledge transfer
  SUPPORT        // Builder support & resources
  PATHWAYS       // Ecosystem pathways
  VISIBILITY     // Visibility and storytelling
}

enum DeliverableStatus {
  PLANNED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

model SponsorVisitRequest {
  id              String      @id @default(cuid())
  eventSponsorId  String      // Links to EventSponsor
  visitType       VisitType
  preferredDates  DateTime[]  // Array of preferred dates
  numAttendees    Int         @default(1)
  purpose         String      // Purpose of visit
  requirements    String?     // Special requirements or logistics needs
  status          VisitStatus @default(PENDING)
  scheduledDate   DateTime?   // Confirmed visit date
  notes           String?     // Admin notes
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  eventSponsor    EventSponsor @relation(fields: [eventSponsorId], references: [id], onDelete: Cascade)

  @@index([eventSponsorId])
  @@index([status])
  @@index([visitType])
}

model SponsorDeliverable {
  id              String              @id @default(cuid())
  eventSponsorId  String
  category        DeliverableCategory
  title           String
  description     String
  status          DeliverableStatus   @default(PLANNED)
  dueDate         DateTime?
  completedAt     DateTime?
  estimatedHours  Int?                // Estimated time commitment
  actualHours     Int?                // Actual time spent
  notes           String?             // Additional notes
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt
  
  eventSponsor    EventSponsor @relation(fields: [eventSponsorId], references: [id], onDelete: Cascade)

  @@index([eventSponsorId])
  @@index([category])
  @@index([status])
}

// Project Ideas System Models
enum SyncStatus {
  PENDING
  SYNCING
  SUCCESS
  FAILED
}

model ProjectIdea {
  id            String   @id @default(cuid())
  title         String
  slug          String   @unique  // URL-safe version of title
  description   String?  // Extracted from markdown overview
  content       String   @db.Text // Full markdown content
  githubPath    String   // projects/filename.md
  technologies  String[] // Extracted tech stack badges
  difficulty    String?  // Easy, Medium, Hard (parsed from content)
  category      String?  // DeFi, Infrastructure, etc.
  
  // GitHub sync metadata
  githubSha     String?  // Git commit SHA for change detection
  lastSynced    DateTime @default(now())
  syncStatus    SyncStatus @default(PENDING)
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([slug])
  @@index([syncStatus])
  @@index([lastSynced])
  @@index([category])
  @@index([difficulty])
}

model ProjectSync {
  id            String   @id @default(cuid())
  totalProjects Int
  syncedCount   Int
  failedCount   Int
  status        SyncStatus
  startedAt     DateTime @default(now())
  completedAt   DateTime?
  errorMessage  String?
  lastCommitSha String?  // Track repository state
  
  @@index([status])
  @@index([startedAt])
}

// Application Evaluation System Models

enum EvaluationStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  REVIEWED
}

enum ReviewStage {
  SCREENING         // Initial screening phase
  DETAILED_REVIEW   // In-depth evaluation
  VIDEO_REVIEW      // Video assessment phase
  CONSENSUS         // Team consensus building
  FINAL_DECISION    // Final decision stage
}

enum CriteriaCategory {
  TECHNICAL         // Technical skills and experience
  PROJECT          // Project quality and feasibility
  COMMUNITY_FIT    // Community alignment and culture fit
  VIDEO            // Video presentation assessment
  ENTREPRENEURIAL  // Entrepreneurial mindset and business acumen
  OVERALL          // Overall impression
}

model EvaluationCriteria {
  id            String          @id @default(cuid())
  name          String          @unique // e.g., "Technical Skills", "Project Viability"
  description   String          // Detailed description of what to evaluate
  category      CriteriaCategory
  weight        Float           @default(1.0) // Weight for final score calculation
  minScore      Int             @default(1)
  maxScore      Int             @default(10)
  isActive      Boolean         @default(true)
  order         Int             // Display order
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt

  // Relations
  scores        EvaluationScore[]

  @@index([category])
  @@index([isActive])
  @@index([order])
}

model ReviewerAssignment {
  id              String   @id @default(cuid())
  applicationId   String
  reviewerId      String   // User ID of the reviewer
  stage           ReviewStage @default(SCREENING)
  priority        Int      @default(0) // Higher priority = more urgent
  assignedAt      DateTime @default(now())
  dueDate         DateTime?
  completedAt     DateTime?
  notes           String?  // Assignment notes or instructions
  
  // Relations
  application     Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  reviewer        User        @relation("ReviewerAssignments", fields: [reviewerId], references: [id], onDelete: Cascade)
  evaluations     ApplicationEvaluation[]

  @@unique([applicationId, reviewerId, stage]) // One assignment per reviewer per stage
  @@index([reviewerId])
  @@index([stage])
  @@index([priority])
  @@index([dueDate])
}

model ApplicationEvaluation {
  id                  String          @id @default(cuid())
  applicationId       String
  reviewerId          String          // User ID of the reviewer
  assignmentId        String          // Links to ReviewerAssignment
  status              EvaluationStatus @default(PENDING)
  stage               ReviewStage
  overallScore        Float?          // Calculated weighted average
  overallComments     String?         @db.Text // General comments about the application
  recommendation      String?         // ACCEPT, REJECT, WAITLIST, NEEDS_MORE_INFO
  confidence          Int?            // Reviewer confidence level (1-5)
  timeSpentMinutes    Int?            // Time spent on evaluation
  
  // Video-specific fields
  videoWatched        Boolean         @default(false)
  videoTimestamp      String?         // JSON array of timestamp notes
  videoQuality        Int?            // Video quality rating (1-5)
  
  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt
  completedAt         DateTime?

  // Relations
  application         Application            @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  reviewer            User                   @relation("ApplicationEvaluations", fields: [reviewerId], references: [id], onDelete: Cascade)
  assignment          ReviewerAssignment     @relation(fields: [assignmentId], references: [id], onDelete: Cascade)
  scores              EvaluationScore[]
  comments            EvaluationComment[]

  @@unique([applicationId, reviewerId, stage]) // One evaluation per reviewer per stage
  @@index([reviewerId])
  @@index([status])
  @@index([stage])
  @@index([overallScore])
  @@index([recommendation])
}

model EvaluationScore {
  id            String    @id @default(cuid())
  evaluationId  String
  criteriaId    String
  score         Float     // The actual score given
  reasoning     String?   @db.Text // Explanation for the score
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  evaluation    ApplicationEvaluation @relation(fields: [evaluationId], references: [id], onDelete: Cascade)
  criteria      EvaluationCriteria    @relation(fields: [criteriaId], references: [id], onDelete: Cascade)

  @@unique([evaluationId, criteriaId]) // One score per criteria per evaluation
  @@index([score])
}

model EvaluationComment {
  id            String    @id @default(cuid())
  evaluationId  String
  questionKey   String?   // Which application question this relates to
  comment       String    @db.Text
  isPrivate     Boolean   @default(true) // Private to reviewers or shared with applicant
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  evaluation    ApplicationEvaluation @relation(fields: [evaluationId], references: [id], onDelete: Cascade)

  @@index([evaluationId])
  @@index([questionKey])
}

model ReviewConsensus {
  id              String    @id @default(cuid())
  applicationId   String    @unique // One consensus per application
  finalDecision   String?   // ACCEPT, REJECT, WAITLIST
  consensusScore  Float?    // Aggregate consensus score
  discussionNotes String?   @db.Text // Notes from consensus discussion
  decidedBy       String?   // Final decision maker (User ID)
  decidedAt       DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relations
  application     Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  decisionMaker   User?       @relation("ConsensusDecisions", fields: [decidedBy], references: [id])

  @@index([finalDecision])
  @@index([consensusScore])
}

// Reviewer Competency System for Weighted Scoring
model ReviewerCompetency {
  id              String          @id @default(cuid())
  reviewerId      String          // User ID of the reviewer
  category        CriteriaCategory // Which evaluation category this competency applies to
  competencyLevel Int             @default(3) // 1-5 scale (1=Novice, 3=Competent, 5=Expert)
  baseWeight      Float           @default(1.0) // Optional manual weight override
  notes           String?         // Admin notes about this competency rating
  assignedBy      String?         // Who assigned this competency (User ID)
  assignedAt      DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  // Relations
  reviewer        User            @relation("ReviewerCompetencies", fields: [reviewerId], references: [id], onDelete: Cascade)
  assignedByUser  User?           @relation("AssignedCompetencies", fields: [assignedBy], references: [id])

  @@unique([reviewerId, category]) // One competency per reviewer per category
  @@index([reviewerId])
  @@index([category])
  @@index([competencyLevel])
}

// Profile System Models
model UserProfile {
  id                    String   @id @default(cuid())
  userId                String   @unique
  bio                   String?  @db.Text
  jobTitle              String?
  company               String?
  location              String?
  website               String?
  githubUrl             String?
  linkedinUrl           String?
  twitterUrl            String?
  skills                String[] // Array of skill tags
  interests             String[] // Array of interest areas
  availableForMentoring Boolean  @default(false)
  availableForHiring    Boolean  @default(false)
  availableForOfficeHours Boolean @default(false)
  timezone              String?
  languages             String[] // Spoken languages
  yearsOfExperience     Int?
  
  // Additional contact methods
  telegramHandle        String?
  discordHandle         String?
  phoneNumber           String?
  
  // Mentor-specific fields
  mentorshipStyle       String?    @db.Text  // How they approach mentoring
  previousMentoringExp  String?    @db.Text  // Previous mentoring experience
  mentorSpecializations String[]             // Specific areas they want to mentor on
  mentorGoals          String?    @db.Text  // Goals for mentoring
  mentorAvailableDates String[]             // Available time periods
  mentorHoursPerWeek   String?             // Time commitment
  mentorPreferredContact String?           // Preferred contact method
  
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  // Relations
  user                  User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  projects              UserProject[]
  
  @@index([location])
  @@index([availableForMentoring])
  @@index([availableForHiring])
  @@index([availableForOfficeHours])
}

model UserProject {
  id            String      @id @default(cuid())
  profileId     String
  title         String
  description   String?     @db.Text
  githubUrl     String?
  liveUrl       String?
  imageUrl      String?     // Project screenshot/logo
  technologies  String[]    // Tech stack used
  featured      Boolean     @default(false)
  order         Int         @default(0)
  
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  
  // Relations
  profile       UserProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)
  
  @@index([profileId])
  @@index([featured])
}

model ProfileSync {
  id            String   @id @default(cuid())
  userId        String
  applicationId String
  syncedFields  String[] // Which fields were copied (e.g., ["skills", "bio", "location"])
  syncedAt      DateTime @default(now())
  
  // Relations
  user         User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  application  Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  
  @@unique([userId, applicationId]) // Prevent duplicate syncs per application
  @@index([userId])
  @@index([applicationId])
  @@index([syncedAt])
}

// Onboarding System Enums
enum DietType {
  OMNIVORE
  VEGETARIAN
  VEGAN
  OTHER
}

enum MentoringOpenness {
  YES
  NO
  MAYBE
}

// Onboarding System Models
model ApplicationOnboarding {
  id                      String   @id @default(cuid())
  applicationId           String   @unique // One onboarding per application
  
  // Contact & Logistics
  legalName               String?  // Legal name as in passport
  passportNumber          String?  // Passport number
  needsVisaLetter         Boolean? // Needs visa letter
  bloodType               String?  // Blood type
  emergencyContactName    String?  // Emergency contact name
  emergencyContactRelationship String? // Emergency contact relationship
  emergencyContactPhone   String?  // Emergency contact phone/WhatsApp
  arrivalDateTime         DateTime? // Arrival date and time in Buenos Aires
  departureDateTime       DateTime? // Departure date and time
  
  // Travel Documents
  eTicketUrl              String?  // URL to uploaded e-ticket file
  eTicketFileName         String?  // Original filename
  healthInsuranceUrl      String?  // URL to uploaded insurance proof
  healthInsuranceFileName String?  // Original filename
  
  // Food & Dietary Needs
  dietType                DietType? // Diet type (omnivore, vegetarian, vegan, other)
  dietTypeOther           String?   // If diet type is "other", specify
  allergiesIntolerances   String?   @db.Text // Allergies or intolerances
  dietaryRequirements     String?   @db.Text // Legacy field, keeping for backward compatibility
  
  // English Proficiency
  englishProficiencyLevel Int?     // English proficiency level (0-100)
  
  // Knowledge Sharing, Community & Mentorship
  primaryGoals            String?  @db.Text // Primary goals for participating
  skillsToGain            String?  @db.Text // Skills or knowledge to gain
  openToMentoring         MentoringOpenness? // Open to mentoring others
  mentorsToLearnFrom      String?  @db.Text // Mentors they'd love to learn from
  organizationsToConnect  String?  @db.Text // Organizations to connect with
  
  // Technical Workshop
  technicalWorkshopTitle  String?  // Technical workshop title
  technicalWorkshopDescription String? @db.Text // Technical workshop description
  technicalWorkshopDuration String? // Technical workshop duration
  technicalWorkshopMaterials String? @db.Text // Technical workshop materials needed
  
  // Beyond Work Activities
  beyondWorkInterests     String?  @db.Text // Other interests or skills to share
  beyondWorkTitle         String?  // Beyond work workshop title
  beyondWorkDescription   String?  @db.Text // Beyond work workshop description
  beyondWorkDuration      String?  // Beyond work workshop duration
  beyondWorkMaterials     String?  @db.Text // Beyond work workshop materials needed
  
  // Media & Bio
  headshotUrl             String?  // URL to uploaded headshot
  headshotFileName        String?  // Original headshot filename
  shortBio                String?  @db.Text // Short bio or description
  
  // Commitments & Confirmations
  participateExperiments  Boolean  @default(false)
  mintHypercert          Boolean  @default(false)
  interestedIncubation   Boolean  @default(false)
  liabilityWaiverConsent  Boolean  @default(false) // Liability waiver consent
  codeOfConductAgreement  Boolean  @default(false) // Code of conduct agreement
  communityActivitiesConsent Boolean @default(false) // Community activities participation
  
  // Additional Information
  additionalComments     String?  @db.Text
  
  // Metadata
  completed              Boolean  @default(false)
  submittedAt            DateTime?
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt
  
  // Relations
  application            Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  
  @@index([applicationId])
  @@index([completed])
  @@index([submittedAt])
}

// Telegram Authentication System
model TelegramAuth {
  id                String   @id @default(cuid())
  userId            String   @unique
  encryptedApiId    String   // Encrypted API ID (user-specific)
  encryptedApiHash  String   // Encrypted API hash (user-specific)
  encryptedSession  String   @db.Text // Encrypted session string
  salt              String   // For key derivation
  iv                String   // Initialization vector for encryption
  expiresAt         DateTime // Session expiration
  isActive          Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([expiresAt])
  @@index([isActive])
}

// Temporary authentication sessions (survives server restarts)
model TelegramAuthSession {
  id              String    @id @default(cuid())
  sessionId       String    @unique // User-generated session ID
  userId          String
  phoneCodeHash   String?   // Telegram phone code hash
  apiId           String?   // User's API ID
  apiHash         String?   // User's API Hash  
  clientData      String?   @db.Text // Serialized client session data
  expiresAt       DateTime  // Session expiration (10 minutes)
  createdAt       DateTime  @default(now())
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([sessionId])
  @@index([userId])
  @@index([expiresAt])
}

// Skills System Models
model Skills {
  id          String   @id @default(cuid())
  name        String   @unique // Skill name (e.g., "React", "Solidity", "Product Management")
  category    String?  // Optional category (e.g., "Frontend", "Backend", "Design", "Blockchain")
  popularity  Int      @default(0) // For sorting suggestions by popularity
  isActive    Boolean  @default(true) // For soft deletion
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  userSkills  UserSkills[]
  
  @@index([category])
  @@index([popularity])
  @@index([isActive])
  @@index([name])
}

model UserSkills {
  id              String   @id @default(cuid())
  userId          String   // User who has this skill
  skillId         String   // Reference to Skills table
  experienceLevel Int?     // Optional 1-10 experience level
  createdAt       DateTime @default(now())
  
  // Relations
  user            User     @relation("UserSkills", fields: [userId], references: [id], onDelete: Cascade)
  skill           Skills   @relation(fields: [skillId], references: [id], onDelete: Cascade)
  
  @@unique([userId, skillId]) // Prevent duplicate skills per user
  @@index([userId])
  @@index([skillId])
  @@index([experienceLevel])
}