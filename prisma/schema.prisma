// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    // NOTE: When using mysql or sqlserver, uncomment the @db.Text annotations in model Account below
    // Further reading:
    // https://next-auth.js.org/adapters/prisma#create-the-prisma-schema
    // https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#string
    url      = env("DATABASE_URL")
}

model Post {
    id        Int      @id @default(autoincrement())
    name      String
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    createdBy   User   @relation(fields: [createdById], references: [id])
    createdById String

    @@index([name])
}

// Necessary for Next auth
model Account {
  id                       String  @id @default(cuid())
  userId                   String
  type                     String
  provider                 String
  providerAccountId        String
  refresh_token            String?
  access_token             String?
  expires_at               Int?
  token_type               String?
  scope                    String?
  id_token                 String?
  session_state            String?
  refresh_token_expires_in Int?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
    id           String   @id @default(cuid())
    sessionToken String   @unique
    userId       String
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  password      String?   // Hashed password for email/password authentication
  role          String?   @default("user") // Add simple role field
  accounts      Account[]
  sessions      Session[]
  posts         Post[]

  teamMemberships TeamMembership[]
  mentorSessions  MentorshipSession[] @relation("MentorSessions")
  createdHackathons Hackathon[]       @relation("HackathonCreatedBy")
  createdProjects Project[]           @relation("ProjectCreatedBy")
  judgedScores   Score[]              @relation("JudgedBy")
  judge           Judge?
  userRoles       UserRole[]
  userGlobalRoles UserGlobalRole[] // Keep for backward compatibility but use role field primarily
  createdEvents   Event[]              @relation("EventsCreatedBy")
  applications    Application[]
}

model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
}

model Event {
  id          String   @id @default(cuid())
  name        String
  description String?
  startDate   DateTime
  endDate     DateTime
  location    String?
  type        String   // e.g., "HACKATHON", "DINNER", "CONFERENCE"
  isOnline    Boolean  @default(true)

  createdBy   User     @relation("EventsCreatedBy", fields: [createdById], references: [id])
  createdById String

  hackathon   Hackathon?
  // Add other event-specific relations as needed

  userRoles   UserRole[]
  sponsors    EventSponsor[]
  applications Application[]
  applicationQuestions ApplicationQuestion[]
  emails      Email[]  // Emails related to this event
  invitations Invitation[]  // Invitations for this event
}

model Hackathon {
  id          String   @id @default(cuid())
  name        String
  description String
  startDate   DateTime
  endDate     DateTime
  location    String?
  isOnline    Boolean  @default(true)

  createdBy   User     @relation("HackathonCreatedBy", fields: [createdById], references: [id])
  createdById String

  teams       Team[]
  tracks      Track[]
  announcements Announcement[]

  event Event? @relation(fields: [eventId], references: [id])
  eventId String? @unique
}

model Track {
  id          String   @id @default(cuid())
  name        String
  description String?
  hackathon   Hackathon @relation(fields: [hackathonId], references: [id])
  hackathonId String

  projects    Project[]
}

model Team {
  id          String   @id @default(cuid())
  name        String
  hackathon   Hackathon @relation(fields: [hackathonId], references: [id])
  hackathonId String

  members     TeamMembership[]
  project     Project?
  mentorshipSessions MentorshipSession[]
}

model TeamMembership {
  id      String @id @default(cuid())
  user    User   @relation(fields: [userId], references: [id])
  userId  String
  team    Team   @relation(fields: [teamId], references: [id])
  teamId  String

  joinedAt DateTime @default(now())

  @@unique([userId, teamId])
}

model Project {
  id          String   @id @default(cuid())
  title       String
  description String?
  repoUrl     String?
  demoUrl     String?
  videoUrl    String?
  submissionDate DateTime?

  team        Team     @relation(fields: [teamId], references: [id])
  teamId      String   @unique

  track       Track?   @relation(fields: [trackId], references: [id])
  trackId     String?

  createdBy   User     @relation("ProjectCreatedBy", fields: [createdById], references: [id])
  createdById String

  scores      Score[]
}

model Judge {
  id     String @id @default(cuid())
  user   User   @relation(fields: [userId], references: [id])
  userId String @unique

  criteria JudgingCriteria[]
}

model JudgingCriteria {
  id        String @id @default(cuid())
  name      String
  weight    Float  @default(1.0)
  judge     Judge  @relation(fields: [judgeId], references: [id])
  judgeId   String
}

model Score {
  id         String    @id @default(cuid())
  value      Float
  notes      String?
  project    Project   @relation(fields: [projectId], references: [id])
  projectId  String
  judge      User      @relation("JudgedBy", fields: [judgeId], references: [id])
  judgeId    String
  criteria   String
}

model MentorshipSession {
  id        String   @id @default(cuid())
  mentor    User     @relation("MentorSessions", fields: [mentorId], references: [id])
  mentorId  String
  team      Team     @relation(fields: [teamId], references: [id])
  teamId    String
  scheduledAt DateTime
  durationMinutes Int
  notes     String?
}

model Announcement {
  id          String   @id @default(cuid())
  hackathon   Hackathon @relation(fields: [hackathonId], references: [id])
  hackathonId String
  message     String
  publishedAt DateTime @default(now())
}

model Role {
  id        String   @id @default(cuid())
  name      String  
  userRoles UserRole[]
  invitations Invitation[]  // Invitations for this role

  @@unique([name])
}

model UserRole {
  id      String   @id @default(cuid())
  user    User     @relation(fields: [userId], references: [id])
  userId  String
  event   Event    @relation(fields: [eventId], references: [id])
  eventId String
  role    Role     @relation(fields: [roleId], references: [id])
  roleId  String

  @@unique([userId, eventId, roleId])
}

model Sponsor {
  id          String         @id @default(cuid())
  name        String         @unique
  websiteUrl  String?
  logoUrl     String?
  events      EventSponsor[]
  contacts    Contact[]
  categories  SponsorCategory[]
  geckoCoin   GeckoCoin?
}

model EventSponsor {
  id        String   @id @default(cuid())
  event     Event    @relation(fields: [eventId], references: [id])
  eventId   String
  sponsor   Sponsor  @relation(fields: [sponsorId], references: [id])
  sponsorId String
  qualified Boolean  @default(false)

  visitRequests SponsorVisitRequest[]
  deliverables  SponsorDeliverable[]

  @@unique([eventId, sponsorId])
}

model Contact {
  id        String @id @default(cuid())
  firstName String
  lastName  String
  email     String @unique
  sponsor   Sponsor? @relation(fields: [sponsorId], references: [id])
  sponsorId String?
  linkedIn  String?
  telegram  String?
  phone     String?
}

model GeckoCoin {
  id                              String   @id @default(cuid())
  geckoId                         String   @unique // CoinGecko's unique ID
  symbol                          String
  name                            String
  image                           String?
  currentPrice                    Float?
  marketCap                       Float?
  marketCapRank                   Int?
  fullyDilutedValuation           Float?
  totalVolume                     Float?
  high24h                         Float?
  low24h                          Float?
  priceChange24h                  Float?
  priceChangePercentage24h        Float?
  marketCapChange24h              Float?
  marketCapChangePercentage24h    Float?
  circulatingSupply               Float?
  totalSupply                     Float?
  maxSupply                       Float?
  ath                             Float?
  athChangePercentage             Float?
  athDate                         DateTime?
  atl                             Float?
  atlChangePercentage             Float?
  atlDate                         DateTime?
  roiTimes                        Float?
  roiCurrency                     String?
  roiPercentage                   Float?
  lastUpdated                     DateTime?
  createdAt                       DateTime @default(now())
  updatedAt                       DateTime @updatedAt

  sponsorId                       String? @unique
  sponsor                         Sponsor? @relation(fields: [sponsorId], references: [id])

  categories                      CategoryGeckoCoin[]
}

model Category {
  id        String   @id @default(cuid())
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sponsors  SponsorCategory[]
  geckoCoins CategoryGeckoCoin[]
}

model SponsorCategory {
  id         String   @id @default(cuid())
  sponsor    Sponsor  @relation(fields: [sponsorId], references: [id])
  sponsorId  String
  category   Category @relation(fields: [categoryId], references: [id])
  categoryId String
  createdAt  DateTime @default(now())

  @@unique([sponsorId, categoryId])
}

model CategoryGeckoCoin {
  id         String    @id @default(cuid())
  category   Category  @relation(fields: [categoryId], references: [id])
  categoryId String
  geckoCoin  GeckoCoin @relation(fields: [geckoId], references: [id])
  geckoId    String
  createdAt  DateTime  @default(now())

  @@unique([categoryId, geckoId])
}

model GlobalRole {
  id             String @id @default(cuid())
  name           String @unique
  description    String?
  permissions    String[] // JSON array of permissions like ["events:read", "contacts:read", "imports:write"]
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  userGlobalRoles UserGlobalRole[]
}

model UserGlobalRole {
  id           String @id @default(cuid())
  user         User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId       String
  globalRole   GlobalRole @relation(fields: [globalRoleId], references: [id], onDelete: Cascade)
  globalRoleId String
  assignedAt   DateTime @default(now())
  assignedBy   String? // Optional: track who assigned the role

  @@unique([userId, globalRoleId])
}

// Application System Models

enum ApplicationStatus {
  DRAFT
  SUBMITTED
  UNDER_REVIEW
  ACCEPTED
  REJECTED
  WAITLISTED
}

enum QuestionType {
  TEXT
  TEXTAREA
  EMAIL
  PHONE
  URL
  SELECT
  MULTISELECT
  CHECKBOX
  NUMBER
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  EXPIRED
  CANCELLED
}

enum InvitationType {
  EVENT_ROLE      // For event-specific roles (mentor, sponsor, etc.)
  GLOBAL_ADMIN    // For global admin access
  GLOBAL_STAFF    // For global staff access
}

model Application {
  id            String   @id @default(cuid())
  userId        String?  // Optional initially for legacy data
  eventId       String   // Links to event
  email         String   // For matching legacy submissions
  status        ApplicationStatus @default(DRAFT)
  language      String   @default("en") // User's preferred language
  isComplete    Boolean  @default(false) // Tracks if all required fields are filled
  completedAt   DateTime? // When it became complete
  lastIncompleteAt DateTime? // Last time it was incomplete (for notifications)
  submittedAt   DateTime?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // Legacy data tracking
  googleFormId  String?  // If migrated from Google Forms
  notionPageId  String?  // If migrated from Notion Forms
  
  user          User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  event         Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  responses     ApplicationResponse[]
  emails        Email[]  // Emails related to this application
  
  @@unique([userId, eventId]) // One application per user per event
  @@index([email])
  @@index([status])
}

model ApplicationQuestion {
  id            String   @id @default(cuid())
  eventId       String   // Questions can be event-specific
  order         Int      // Display order
  questionKey   String   // Unique key for the question (e.g., "full_name", "email")
  questionEn    String   // Question in English
  questionEs    String   // Question in Spanish
  questionType  QuestionType
  required      Boolean  @default(true)
  options       String[] // For multiple choice questions (JSON array)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  event         Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  responses     ApplicationResponse[]
  
  @@unique([eventId, questionKey]) // Unique question per event
  @@index([eventId, order])
}

model ApplicationResponse {
  id            String   @id @default(cuid())
  applicationId String
  questionId    String
  answer        String   // Store answer as text (JSON for complex responses)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  application   Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  question      ApplicationQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)
  
  @@unique([applicationId, questionId])
  @@index([applicationId])
}

// Invitation System Models
model Invitation {
  id          String   @id @default(cuid())
  email       String   // Email to invite
  type        InvitationType @default(EVENT_ROLE) // Type of invitation
  eventId     String?  // Which event they're being invited to (null for global roles)
  roleId      String?  // What event role they'll get (null for global roles)
  globalRole  String?  // Global role for global invitations (admin, staff)
  
  status      InvitationStatus @default(PENDING)
  expiresAt   DateTime
  invitedBy   String   // Admin who sent invitation
  token       String   @unique @default(cuid()) // For invitation links
  
  createdAt   DateTime @default(now())
  acceptedAt  DateTime?
  
  event       Event?   @relation(fields: [eventId], references: [id], onDelete: Cascade)
  role        Role?    @relation(fields: [roleId], references: [id], onDelete: Cascade)
  
  @@unique([email, eventId, roleId]) // Prevent duplicate event role invites
  @@unique([email, type, globalRole]) // Prevent duplicate global role invites
  @@index([email])
  @@index([token])
  @@index([status])
  @@index([type])
}

// Email System Models
enum EmailStatus {
  DRAFT
  QUEUED
  SENT
  FAILED
  CANCELLED
}

enum EmailType {
  // Application related
  APPLICATION_SUBMITTED
  APPLICATION_ACCEPTED
  APPLICATION_REJECTED  
  APPLICATION_WAITLISTED
  APPLICATION_UNDER_REVIEW
  APPLICATION_MISSING_INFO
  
  // Invitation related
  INVITATION_EVENT_ROLE
  INVITATION_ADMIN
  
  // General
  GENERAL
  TEST
  
  // Legacy (for backward compatibility)
  MISSING_INFO    // Deprecated: Use APPLICATION_MISSING_INFO
  STATUS_UPDATE   // Deprecated: Use specific status types
}

model Email {
  id            String      @id @default(cuid())
  applicationId String?     // Optional: link to specific application
  eventId       String      // Required: link to event
  toEmail       String      // Recipient email address
  fromEmail     String      @default("james@fundingthecommons.io") // Always send from this for testing
  subject       String      // Email subject line
  htmlContent   String      @db.Text // HTML version of email
  textContent   String?     @db.Text // Plain text version (optional)
  type          EmailType   @default(MISSING_INFO)
  status        EmailStatus @default(DRAFT)
  
  // Metadata
  missingFields String[]    // JSON array of missing field keys (for MISSING_INFO emails)
  createdBy     String      // User ID who created the email
  sentAt        DateTime?   // When email was actually sent
  failureReason String?     // Error message if sending failed
  postmarkId    String?     // Postmark message ID for tracking
  
  // Template tracking
  templateName    String?     // Which template was used (e.g., "application_accepted")
  templateVersion String?     // Template version for tracking changes
  templateData    Json?       // JSON data used to render template
  openedAt        DateTime?   // When email was opened (if tracking enabled)
  clickedAt       DateTime?   // When links were clicked (if tracking enabled)
  
  // Timestamps
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  
  // Relations
  application   Application? @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  event         Event       @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  @@index([applicationId])
  @@index([eventId])
  @@index([status])
  @@index([toEmail])
}

// Sponsor Residency Models
enum VisitType {
  KICKOFF        // Opening week kickoff (1-2 days)
  MENTORSHIP     // Mid-program mentorship visit
  DEMO_DAY       // Final showcase/demo day
  CUSTOM         // Custom dates
}

enum VisitStatus {
  PENDING
  APPROVED
  SCHEDULED
  COMPLETED
  CANCELLED
}

enum DeliverableCategory {
  TECHNICAL      // Technical mentorship & knowledge transfer
  SUPPORT        // Builder support & resources
  PATHWAYS       // Ecosystem pathways
  VISIBILITY     // Visibility and storytelling
}

enum DeliverableStatus {
  PLANNED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

model SponsorVisitRequest {
  id              String      @id @default(cuid())
  eventSponsorId  String      // Links to EventSponsor
  visitType       VisitType
  preferredDates  DateTime[]  // Array of preferred dates
  numAttendees    Int         @default(1)
  purpose         String      // Purpose of visit
  requirements    String?     // Special requirements or logistics needs
  status          VisitStatus @default(PENDING)
  scheduledDate   DateTime?   // Confirmed visit date
  notes           String?     // Admin notes
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  eventSponsor    EventSponsor @relation(fields: [eventSponsorId], references: [id], onDelete: Cascade)

  @@index([eventSponsorId])
  @@index([status])
  @@index([visitType])
}

model SponsorDeliverable {
  id              String              @id @default(cuid())
  eventSponsorId  String
  category        DeliverableCategory
  title           String
  description     String
  status          DeliverableStatus   @default(PLANNED)
  dueDate         DateTime?
  completedAt     DateTime?
  estimatedHours  Int?                // Estimated time commitment
  actualHours     Int?                // Actual time spent
  notes           String?             // Additional notes
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt
  
  eventSponsor    EventSponsor @relation(fields: [eventSponsorId], references: [id], onDelete: Cascade)

  @@index([eventSponsorId])
  @@index([category])
  @@index([status])
}

// Project Ideas System Models
enum SyncStatus {
  PENDING
  SYNCING
  SUCCESS
  FAILED
}

model ProjectIdea {
  id            String   @id @default(cuid())
  title         String
  slug          String   @unique  // URL-safe version of title
  description   String?  // Extracted from markdown overview
  content       String   @db.Text // Full markdown content
  githubPath    String   // projects/filename.md
  technologies  String[] // Extracted tech stack badges
  difficulty    String?  // Easy, Medium, Hard (parsed from content)
  category      String?  // DeFi, Infrastructure, etc.
  
  // GitHub sync metadata
  githubSha     String?  // Git commit SHA for change detection
  lastSynced    DateTime @default(now())
  syncStatus    SyncStatus @default(PENDING)
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([slug])
  @@index([syncStatus])
  @@index([lastSynced])
  @@index([category])
  @@index([difficulty])
}

model ProjectSync {
  id            String   @id @default(cuid())
  totalProjects Int
  syncedCount   Int
  failedCount   Int
  status        SyncStatus
  startedAt     DateTime @default(now())
  completedAt   DateTime?
  errorMessage  String?
  lastCommitSha String?  // Track repository state
  
  @@index([status])
  @@index([startedAt])
}