// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    // NOTE: When using mysql or sqlserver, uncomment the @db.Text annotations in model Account below
    // Further reading:
    // https://next-auth.js.org/adapters/prisma#create-the-prisma-schema
    // https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#string
    url      = env("DATABASE_URL")
}

model Post {
    id        Int      @id @default(autoincrement())
    name      String
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    createdBy   User   @relation(fields: [createdById], references: [id], onDelete: Cascade)
    createdById String

    @@index([name])
}

// Necessary for Next auth
model Account {
  id                       String  @id @default(cuid())
  userId                   String
  type                     String
  provider                 String
  providerAccountId        String
  refresh_token            String?
  access_token             String?
  expires_at               Int?
  token_type               String?
  scope                    String?
  id_token                 String?
  session_state            String?
  refresh_token_expires_in Int?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
    id           String   @id @default(cuid())
    sessionToken String   @unique
    userId       String
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id            String    @id @default(cuid())
  name          String?   // Legacy field - kept for migration period
  firstName     String?
  surname       String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  password      String?   // Hashed password for email/password authentication
  role          String?   @default("user") // Add simple role field
  isAIReviewer  Boolean   @default(false) // Identifies AI reviewers like Elinor Ostrom
  kudos         Float     @default(130.0) // Social credit score (130 = 13 days Ã— 10 kudos/day)
  accounts      Account[]
  sessions      Session[]
  posts         Post[]

  userRoles       UserRole[]
  userGlobalRoles UserGlobalRole[] // Keep for backward compatibility but use role field primarily
  createdEvents   Event[]              @relation("EventsCreatedBy")
  applications    Application[]
  
  // Evaluation system relations
  reviewerAssignments    ReviewerAssignment[]     @relation("ReviewerAssignments")
  applicationEvaluations ApplicationEvaluation[]  @relation("ApplicationEvaluations")
  consensusDecisions     ReviewConsensus[]        @relation("ConsensusDecisions")
  
  // Reviewer competency relations
  reviewerCompetencies   ReviewerCompetency[]     @relation("ReviewerCompetencies")
  assignedCompetencies   ReviewerCompetency[]     @relation("AssignedCompetencies")
  
  // Internal admin fields for user management
  adminNotes          String?   @db.Text  // Internal admin notes about this user
  adminWorkExperience String?   @db.Text  // LinkedIn work experience copy
  adminLabels         String[]             // Array: 'Entrepreneur', 'Developer', 'Designer', 'Researcher'
  adminUpdatedBy      String?              // Admin who last updated these fields
  adminUpdatedAt      DateTime?            // When admin fields were last updated
  
  // Profile system relations
  profile        UserProfile?
  profileSyncs   ProfileSync[]
  
  // Admin update relations
  adminUpdater    User?     @relation("AdminUpdates", fields: [adminUpdatedBy], references: [id])
  adminUpdates    User[]    @relation("AdminUpdates")
  
  // Telegram authentication relation
  telegramAuth         TelegramAuth?
  telegramAuthSessions TelegramAuthSession[]
  
  // Skills system relation
  userSkills           UserSkills[]         @relation("UserSkills")
  
  // Contact interaction relation
  contactInteractions  ContactInteraction[] @relation("ContactInteractions")
  
  // Analytics system relations
  analyticsAudits      AnalyticsAudit[]     @relation("AnalyticsAudits")
  analyticsRateLimits  AnalyticsRateLimit[] @relation("AnalyticsRateLimits")
  
  // Password reset tokens
  passwordResetTokens  PasswordResetToken[] @relation("PasswordResetTokens")
  
  // Project update relations
  projectUpdates       ProjectUpdate[]        @relation("ProjectUpdates")
  projectUpdateLikes   ProjectUpdateLike[]    @relation("ProjectUpdateLikes")
  projectUpdateComments ProjectUpdateComment[] @relation("ProjectUpdateComments")
  projectUpdateCommentLikes ProjectUpdateCommentLike[] @relation("ProjectUpdateCommentLikes")
  userProjectLikes     UserProjectLike[]      @relation("UserProjectLikes")
  askOfferLikes        AskOfferLike[]         @relation("AskOfferLikes")

  // Asks and Offers relations
  asksOffers           AskOffer[]           @relation("UserAsksOffers")
  askOfferComments     AskOfferComment[]    @relation("UserAskOfferComments")
  askOfferCommentLikes AskOfferCommentLike[] @relation("AskOfferCommentLikes")

  // Praise relations
  praiseSent           Praise[]             @relation("PraiseSent")
  praiseReceived       Praise[]             @relation("PraiseReceived")

  // Project collaboration relation
  projectCollaborations ProjectCollaborator[] @relation("ProjectCollaborations")

  // Metrics relations
  createdMetrics        Metric[]              @relation("MetricsCreated")
  metricMeasurements    MetricMeasurement[]   @relation("MetricMeasurements")
  projectMetricsAdded   ProjectMetric[]       @relation("ProjectMetricsAdded")

  // AT Proto integration relation
  atProtoAccount        AtProtoAccount?

  // Wallet addresses relation
  walletAddresses       WalletAddress[]     @relation("UserWalletAddresses")

  // Forum system relations
  forumThreads          ForumThread[]       @relation("UserForumThreads")
  forumComments         ForumComment[]      @relation("UserForumComments")
  forumThreadLikes      ForumThreadLike[]   @relation("ForumThreadLikes")
  forumCommentLikes     ForumCommentLike[]  @relation("ForumCommentLikes")

  // Venue ownership relations (floor owners)
  venueOwnerships       VenueOwner[]        @relation("VenueOwners")

  // Session speaker relations
  sessionSpeakers       SessionSpeaker[]    @relation("SessionSpeakers")
}

model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique  // Hashed token for security
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User     @relation("PasswordResetTokens", fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
  @@index([expiresAt])
}

enum EventStatus {
  ACTIVE
  COMPLETED
  CANCELLED
}

model Event {
  id          String      @id @default(cuid())
  slug        String?     @unique  // URL-friendly identifier, auto-generated from name
  name        String
  description String?
  startDate   DateTime
  endDate     DateTime
  location    String?
  type        String      // e.g., "HACKATHON", "DINNER", "CONFERENCE"
  isOnline    Boolean     @default(true)
  status      EventStatus @default(ACTIVE)

  // Feature flags (all default to true for backward compatibility)
  featureApplicantVetting  Boolean @default(true)
  featureSpeakerVetting    Boolean @default(true)
  featureMentorVetting     Boolean @default(true)
  featurePraise            Boolean @default(true)
  featureProjects          Boolean @default(true)
  featureAsksOffers        Boolean @default(true)
  featureNewsfeed          Boolean @default(true)
  featureImpactAnalytics     Boolean @default(true)
  featureSponsorManagement   Boolean @default(true)

  createdBy   User?    @relation("EventsCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
  createdById String?

  // Add other event-specific relations as needed

  userRoles   UserRole[]
  sponsors    EventSponsor[]
  applications Application[]
  applicationQuestions ApplicationQuestion[]
  communications Communication[]  // Communications related to this event
  emails      Email[]  // Legacy: Emails related to this event (for backward compatibility)
  invitations Invitation[]  // Invitations for this event
  asksOffers  AskOffer[]  @relation("EventAsksOffers")  // Asks and Offers for this event
  praises     Praise[]    @relation("EventPraises")  // Praise messages for this event
  metricMeasurements MetricMeasurement[] // Measurements during this event
  repositoryMetrics RepositoryResidencyMetrics[] @relation("RepositoryMetrics") // GitHub metrics for this residency

  // Feature flag for schedule management
  featureScheduleManagement Boolean @default(false)

  // Feature flag for floor management
  featureFloorManagement Boolean @default(false)

  // Schedule system relations
  scheduleVenues       ScheduleVenue[]
  scheduleSessionTypes ScheduleSessionType[]
  scheduleTracks       ScheduleTrack[]
  scheduleSessions     ScheduleSession[]

  // Venue ownership relations (floor owners)
  venueOwners          VenueOwner[]

  @@index([slug])
}

model Role {
  id        String   @id @default(cuid())
  name      String  
  userRoles UserRole[]
  invitations Invitation[]  // Invitations for this role

  @@unique([name])
}

model UserRole {
  id      String   @id @default(cuid())
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId  String
  event   Event    @relation(fields: [eventId], references: [id])
  eventId String
  role    Role     @relation(fields: [roleId], references: [id])
  roleId  String

  // Judge-specific fields
  ethereumAddress String? // For hackathon judging (optional, only relevant for judge roles)

  @@unique([userId, eventId, roleId])
}

model Sponsor {
  id          String         @id @default(cuid())
  name        String         @unique
  websiteUrl  String?
  logoUrl     String?
  events      EventSponsor[]
  contacts    Contact[]
  categories  SponsorCategory[]
  geckoCoin   GeckoCoin?
}

model EventSponsor {
  id        String   @id @default(cuid())
  event     Event    @relation(fields: [eventId], references: [id])
  eventId   String
  sponsor   Sponsor  @relation(fields: [sponsorId], references: [id])
  sponsorId String
  qualified Boolean  @default(false)

  visitRequests SponsorVisitRequest[]
  deliverables  SponsorDeliverable[]

  @@unique([eventId, sponsorId])
}

model Contact {
  id        String @id @default(cuid())
  firstName String
  lastName  String
  email     String? // Made optional - removed @unique constraint
  sponsor   Sponsor? @relation(fields: [sponsorId], references: [id])
  sponsorId String?
  linkedIn  String?
  telegram  String?
  twitter   String?
  github   String?
  phone     String?
  
  // New fields
  about     String? @db.Text // Free text description
  skills    String[] // Array of skill tags
  
  // Cached last interaction data for quick access
  lastInteractionAt   DateTime?
  lastInteractionType String?
  lastInteractionBy   String? // User ID who made last contact
  
  // Relations
  interactions ContactInteraction[]
}

model ContactInteraction {
  id            String   @id @default(cuid())
  contactId     String   // Which contact
  userId        String   // Which platform user initiated the interaction
  
  // Interaction details
  type          String   // "EMAIL", "TELEGRAM", "PHONE_CALL", "MEETING", "NOTE", etc.
  direction     String   // "OUTBOUND", "INBOUND" 
  subject       String?  // Email subject, call purpose, meeting topic, etc.
  notes         String?  @db.Text // Interaction notes/summary
  
  // Platform integration tracking
  communicationId String? // Link to Communication table if sent via platform
  telegramMsgId   String? // If telegram message
  emailId         String? // If email sent
  
  // Metadata
  createdAt     DateTime @default(now())
  interactedAt  DateTime @default(now()) // When interaction actually happened
  
  // Relations
  contact       Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)
  user          User    @relation("ContactInteractions", fields: [userId], references: [id], onDelete: Cascade)
  communication Communication? @relation(fields: [communicationId], references: [id])
  
  @@index([contactId])
  @@index([userId])
  @@index([interactedAt])
  @@index([type])
}

model GeckoCoin {
  id                              String   @id @default(cuid())
  geckoId                         String   @unique // CoinGecko's unique ID
  symbol                          String
  name                            String
  image                           String?
  currentPrice                    Float?
  marketCap                       Float?
  marketCapRank                   Int?
  fullyDilutedValuation           Float?
  totalVolume                     Float?
  high24h                         Float?
  low24h                          Float?
  priceChange24h                  Float?
  priceChangePercentage24h        Float?
  marketCapChange24h              Float?
  marketCapChangePercentage24h    Float?
  circulatingSupply               Float?
  totalSupply                     Float?
  maxSupply                       Float?
  ath                             Float?
  athChangePercentage             Float?
  athDate                         DateTime?
  atl                             Float?
  atlChangePercentage             Float?
  atlDate                         DateTime?
  roiTimes                        Float?
  roiCurrency                     String?
  roiPercentage                   Float?
  lastUpdated                     DateTime?
  createdAt                       DateTime @default(now())
  updatedAt                       DateTime @updatedAt

  sponsorId                       String? @unique
  sponsor                         Sponsor? @relation(fields: [sponsorId], references: [id])

  categories                      CategoryGeckoCoin[]
}

model Category {
  id        String   @id @default(cuid())
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sponsors  SponsorCategory[]
  geckoCoins CategoryGeckoCoin[]
}

model SponsorCategory {
  id         String   @id @default(cuid())
  sponsor    Sponsor  @relation(fields: [sponsorId], references: [id])
  sponsorId  String
  category   Category @relation(fields: [categoryId], references: [id])
  categoryId String
  createdAt  DateTime @default(now())

  @@unique([sponsorId, categoryId])
}

model CategoryGeckoCoin {
  id         String    @id @default(cuid())
  category   Category  @relation(fields: [categoryId], references: [id])
  categoryId String
  geckoCoin  GeckoCoin @relation(fields: [geckoId], references: [id])
  geckoId    String
  createdAt  DateTime  @default(now())

  @@unique([categoryId, geckoId])
}

model GlobalRole {
  id             String @id @default(cuid())
  name           String @unique
  description    String?
  permissions    String[] // JSON array of permissions like ["events:read", "contacts:read", "imports:write"]
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  userGlobalRoles UserGlobalRole[]
}

model UserGlobalRole {
  id           String @id @default(cuid())
  user         User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId       String
  globalRole   GlobalRole @relation(fields: [globalRoleId], references: [id], onDelete: Cascade)
  globalRoleId String
  assignedAt   DateTime @default(now())
  assignedBy   String? // Optional: track who assigned the role

  @@unique([userId, globalRoleId])
}

// Application System Models

enum ApplicationStatus {
  DRAFT
  SUBMITTED
  UNDER_REVIEW
  ACCEPTED
  REJECTED
  WAITLISTED
  CANCELLED
}

enum ApplicationType {
  RESIDENT
  MENTOR
  SPEAKER
}

enum QuestionType {
  TEXT
  TEXTAREA
  EMAIL
  PHONE
  URL
  SELECT
  MULTISELECT
  CHECKBOX
  NUMBER
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  EXPIRED
  CANCELLED
}

enum InvitationType {
  EVENT_ROLE      // For event-specific roles (mentor, sponsor, etc.)
  GLOBAL_ADMIN    // For global admin access
  GLOBAL_STAFF    // For global staff access
  VENUE_OWNER     // For floor/venue ownership
}

model Application {
  id            String   @id @default(cuid())
  userId        String?  // Optional initially for legacy data
  eventId       String   // Links to event
  email         String   // For matching legacy submissions
  status        ApplicationStatus @default(DRAFT)
  applicationType ApplicationType @default(RESIDENT) // Type of application (resident or mentor)
  language      String   @default("en") // User's preferred language
  affiliation   String?  // Organization or company affiliation
  isComplete    Boolean  @default(false) // Tracks if all required fields are filled
  completedAt   DateTime? // When it became complete
  lastIncompleteAt DateTime? // Last time it was incomplete (for notifications)
  submittedAt   DateTime?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // Waitlist management
  waitlistOrder Int?     // Manual override for waitlist position (null = auto-ranked)
  
  // Invitation linkage
  invitationId  String?  // Links to the invitation that led to this application

  // Legacy data tracking
  googleFormId  String?  // If migrated from Google Forms
  notionPageId  String?  // If migrated from Notion Forms

  user          User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  event         Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  invitation    Invitation? @relation(fields: [invitationId], references: [id])
  responses     ApplicationResponse[]
  communications Communication[]  // Communications related to this application
  emails        Email[]  // Legacy: Emails related to this application (for backward compatibility)
  
  // Evaluation system relations
  reviewerAssignments   ReviewerAssignment[]
  evaluations          ApplicationEvaluation[]
  consensus            ReviewConsensus?
  
  // Profile sync relations
  profileSyncs         ProfileSync[]

  // Onboarding relation
  onboarding           ApplicationOnboarding?

  // Venue/floor associations (many-to-many)
  venues               ApplicationVenue[]

  @@unique([userId, eventId]) // One application per user per event
  @@index([email])
  @@index([status])
  @@index([invitationId])
}

model ApplicationVenue {
  id            String        @id @default(cuid())
  applicationId String
  venueId       String
  createdAt     DateTime      @default(now())

  application   Application   @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  venue         ScheduleVenue @relation(fields: [venueId], references: [id], onDelete: Cascade)

  @@unique([applicationId, venueId])
  @@index([applicationId])
  @@index([venueId])
}

model ApplicationQuestion {
  id            String   @id @default(cuid())
  eventId       String   // Questions can be event-specific
  order         Int      // Display order
  questionKey   String   // Unique key for the question (e.g., "full_name", "email")
  questionEn    String   // Question in English
  questionEs    String   // Question in Spanish
  questionType  QuestionType
  required      Boolean  @default(true)
  options       String[] // For multiple choice questions (JSON array)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  event         Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  responses     ApplicationResponse[]
  
  @@unique([eventId, questionKey]) // Unique question per event
  @@index([eventId, order])
}

model ApplicationResponse {
  id            String   @id @default(cuid())
  applicationId String
  questionId    String
  answer        String   // Store answer as text (JSON for complex responses)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  application   Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  question      ApplicationQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)
  
  @@unique([applicationId, questionId])
  @@index([applicationId])
}

// Invitation System Models
model Invitation {
  id          String   @id @default(cuid())
  email       String   // Email to invite
  inviteeName String?  // Optional first name for email personalization
  type        InvitationType @default(EVENT_ROLE) // Type of invitation
  eventId     String?  // Which event they're being invited to (null for global roles)
  roleId      String?  // What event role they'll get (null for global roles)
  globalRole  String?  // Global role for global invitations (admin, staff)
  
  status      InvitationStatus @default(PENDING)
  expiresAt   DateTime
  invitedBy   String   // Admin who sent invitation
  token       String   @unique @default(cuid()) // For invitation links
  
  createdAt   DateTime @default(now())
  acceptedAt  DateTime?
  
  venueId     String?  // For VENUE_OWNER invitations

  event       Event?          @relation(fields: [eventId], references: [id], onDelete: Cascade)
  role        Role?           @relation(fields: [roleId], references: [id], onDelete: Cascade)
  venue       ScheduleVenue?  @relation(fields: [venueId], references: [id], onDelete: Cascade)
  applications Application[]

  @@unique([email, eventId, roleId]) // Prevent duplicate event role invites
  @@unique([email, type, globalRole]) // Prevent duplicate global role invites
  @@index([email])
  @@index([token])
  @@index([status])
  @@index([type])
}

// Communication System Models
enum CommunicationType {
  EMAIL
  TELEGRAM
  SMS          // Future
  DISCORD      // Future
  WHATSAPP     // Future
}

enum CommunicationStatus {
  DRAFT
  QUEUED
  SENT
  FAILED
  CANCELLED
}

enum CommunicationContentType {
  // Application related
  APPLICATION_SUBMITTED
  APPLICATION_ACCEPTED
  APPLICATION_REJECTED  
  APPLICATION_WAITLISTED
  APPLICATION_UNDER_REVIEW
  APPLICATION_MISSING_INFO
  
  // Invitation related
  INVITATION_EVENT_ROLE
  INVITATION_ADMIN
  
  // General
  GENERAL
  BULK_MESSAGE     // New: For bulk telegram messages
  UPDATE_COMMENT   // New: For project update comment notifications
  FORUM_COMMENT    // New: For forum thread comment notifications
  ASK_OFFER_COMMENT // New: For ask/offer comment notifications
  TEST

  // Legacy (for backward compatibility)
  MISSING_INFO    // Deprecated: Use APPLICATION_MISSING_INFO
  STATUS_UPDATE   // Deprecated: Use specific status types
}

// Legacy enums for backward compatibility
enum EmailStatus {
  DRAFT
  QUEUED
  SENT
  FAILED
  CANCELLED
}

enum EmailType {
  // Application related
  APPLICATION_SUBMITTED
  APPLICATION_ACCEPTED
  APPLICATION_REJECTED  
  APPLICATION_WAITLISTED
  APPLICATION_UNDER_REVIEW
  APPLICATION_MISSING_INFO
  
  // Invitation related
  INVITATION_EVENT_ROLE
  INVITATION_ADMIN

  // Floor owner related
  FLOOR_OWNER_ASSIGNED

  // Authentication related
  PASSWORD_RESET
  MAGIC_LINK
  
  // General
  GENERAL
  TEST

  // Comment notifications
  UPDATE_COMMENT    // For project update comment notifications
  FORUM_COMMENT     // For forum thread comment notifications
  ASK_OFFER_COMMENT // For ask/offer comment notifications

  // Legacy (for backward compatibility)
  MISSING_INFO    // Deprecated: Use APPLICATION_MISSING_INFO
  STATUS_UPDATE   // Deprecated: Use specific status types
}

model Communication {
  id            String      @id @default(cuid())
  applicationId String?     // Optional: link to specific application
  eventId       String?     // Optional: link to event (communications can be event-agnostic)
  
  // Channel-specific sender fields
  fromEmail     String?     @default("james@fundingthecommons.io") // Email sender
  fromTelegram  String?     // Telegram sender (@username or user_id)

  // Channel-specific recipient fields
  toEmail       String?     // For email communications
  toTelegram    String?     // For telegram (@username or user_id)
  toPhone       String?     // For SMS (future)
  toDiscord     String?     // For Discord (future)

  // Channel identification
  channel       CommunicationType @default(EMAIL)

  // Content fields (channel-agnostic)
  subject       String?     // Email subject OR Telegram summary
  htmlContent   String?     @db.Text // HTML email content
  textContent   String      @db.Text // Plain text (required for all channels)
  
  // Status and type (channel-agnostic)
  type          CommunicationContentType @default(MISSING_INFO)
  status        CommunicationStatus @default(DRAFT)
  
  // Metadata (channel-agnostic)
  missingFields String[]    // JSON array of missing field keys
  createdBy     String      // User ID who created
  sentAt        DateTime?   // When actually sent
  failureReason String?     // Error message if sending failed
  
  // Channel-specific tracking IDs
  postmarkId    String?     // Email: Postmark message ID
  telegramMsgId String?     // Telegram: Message ID from API
  
  // Template tracking (channel-agnostic)
  templateName    String?     // Which template was used
  templateVersion String?     // Template version for tracking
  templateData    Json?       // JSON data used to render
  
  // Engagement tracking (channel-specific)
  openedAt        DateTime?   // Email: when opened
  clickedAt       DateTime?   // Email: when links clicked
  readAt          DateTime?   // Telegram: when read (if available)
  
  // Standard timestamps
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  
  // Relations
  application   Application? @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  event         Event?      @relation(fields: [eventId], references: [id], onDelete: Cascade)
  contactInteractions ContactInteraction[] // Contact interactions linked to this communication
  
  // Indexes for performance
  @@index([applicationId])
  @@index([eventId])
  @@index([status])
  @@index([fromEmail])    // Email sender search
  @@index([toEmail])      // Email recipient search
  @@index([fromTelegram]) // Telegram sender search
  @@index([toTelegram])   // Telegram recipient search
  @@index([channel])      // Filter by communication type
  @@index([type])         // Filter by content type
}

// Legacy Email model for backward compatibility (will be populated via view or alias)
model Email {
  id            String      @id @default(cuid())
  applicationId String?     // Optional: link to specific application
  eventId       String      // Required: link to event
  toEmail       String      // Recipient email address
  fromEmail     String      @default("james@fundingthecommons.io") // Always send from this for testing
  subject       String      // Email subject line
  htmlContent   String      @db.Text // HTML version of email
  textContent   String?     @db.Text // Plain text version (optional)
  type          EmailType   @default(MISSING_INFO)
  status        EmailStatus @default(DRAFT)
  
  // Metadata
  missingFields String[]    // JSON array of missing field keys (for MISSING_INFO emails)
  createdBy     String      // User ID who created the email
  sentAt        DateTime?   // When email was actually sent
  failureReason String?     // Error message if sending failed
  postmarkId    String?     // Postmark message ID for tracking
  
  // Template tracking
  templateName    String?     // Which template was used (e.g., "application_accepted")
  templateVersion String?     // Template version for tracking changes
  templateData    Json?       // JSON data used to render template
  openedAt        DateTime?   // When email was opened (if tracking enabled)
  clickedAt       DateTime?   // When links were clicked (if tracking enabled)
  
  // Timestamps
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  
  // Relations
  application   Application? @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  event         Event       @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  @@index([applicationId])
  @@index([eventId])
  @@index([status])
  @@index([toEmail])
}

// Sponsor Residency Models
enum VisitType {
  KICKOFF        // Opening week kickoff (1-2 days)
  MENTORSHIP     // Mid-program mentorship visit
  DEMO_DAY       // Final showcase/demo day
  CUSTOM         // Custom dates
}

enum VisitStatus {
  PENDING
  APPROVED
  SCHEDULED
  COMPLETED
  CANCELLED
}

enum DeliverableCategory {
  TECHNICAL      // Technical mentorship & knowledge transfer
  SUPPORT        // Builder support & resources
  PATHWAYS       // Ecosystem pathways
  VISIBILITY     // Visibility and storytelling
}

enum DeliverableStatus {
  PLANNED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

model SponsorVisitRequest {
  id              String      @id @default(cuid())
  eventSponsorId  String      // Links to EventSponsor
  visitType       VisitType
  preferredDates  DateTime[]  // Array of preferred dates
  numAttendees    Int         @default(1)
  purpose         String      // Purpose of visit
  requirements    String?     // Special requirements or logistics needs
  status          VisitStatus @default(PENDING)
  scheduledDate   DateTime?   // Confirmed visit date
  notes           String?     // Admin notes
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  eventSponsor    EventSponsor @relation(fields: [eventSponsorId], references: [id], onDelete: Cascade)

  @@index([eventSponsorId])
  @@index([status])
  @@index([visitType])
}

model SponsorDeliverable {
  id              String              @id @default(cuid())
  eventSponsorId  String
  category        DeliverableCategory
  title           String
  description     String
  status          DeliverableStatus   @default(PLANNED)
  dueDate         DateTime?
  completedAt     DateTime?
  estimatedHours  Int?                // Estimated time commitment
  actualHours     Int?                // Actual time spent
  notes           String?             // Additional notes
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt
  
  eventSponsor    EventSponsor @relation(fields: [eventSponsorId], references: [id], onDelete: Cascade)

  @@index([eventSponsorId])
  @@index([category])
  @@index([status])
}

// Project Ideas System Models
enum SyncStatus {
  PENDING
  SYNCING
  SUCCESS
  FAILED
}

model ProjectIdea {
  id            String   @id @default(cuid())
  title         String
  slug          String   @unique  // URL-safe version of title
  description   String?  // Extracted from markdown overview
  content       String   @db.Text // Full markdown content
  githubPath    String   // projects/filename.md
  technologies  String[] // Extracted tech stack badges
  difficulty    String?  // Easy, Medium, Hard (parsed from content)
  category      String?  // DeFi, Infrastructure, etc.
  
  // GitHub sync metadata
  githubSha     String?  // Git commit SHA for change detection
  lastSynced    DateTime @default(now())
  syncStatus    SyncStatus @default(PENDING)
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([slug])
  @@index([syncStatus])
  @@index([lastSynced])
  @@index([category])
  @@index([difficulty])
}

model ProjectSync {
  id            String   @id @default(cuid())
  totalProjects Int
  syncedCount   Int
  failedCount   Int
  status        SyncStatus
  startedAt     DateTime @default(now())
  completedAt   DateTime?
  errorMessage  String?
  lastCommitSha String?  // Track repository state
  
  @@index([status])
  @@index([startedAt])
}

// Application Evaluation System Models

enum EvaluationStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  REVIEWED
}

enum ReviewStage {
  SCREENING         // Initial screening phase
  DETAILED_REVIEW   // In-depth evaluation
  VIDEO_REVIEW      // Video assessment phase
  CONSENSUS         // Team consensus building
  FINAL_DECISION    // Final decision stage
}

enum CriteriaCategory {
  TECHNICAL         // Technical skills and experience
  PROJECT          // Project quality and feasibility
  COMMUNITY_FIT    // Community alignment and culture fit
  VIDEO            // Video presentation assessment
  ENTREPRENEURIAL  // Entrepreneurial mindset and business acumen
  OVERALL          // Overall impression
}

model EvaluationCriteria {
  id            String          @id @default(cuid())
  name          String          @unique // e.g., "Technical Skills", "Project Viability"
  description   String          // Detailed description of what to evaluate
  category      CriteriaCategory
  weight        Float           @default(1.0) // Weight for final score calculation
  minScore      Int             @default(1)
  maxScore      Int             @default(10)
  isActive      Boolean         @default(true)
  order         Int             // Display order
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt

  // Relations
  scores        EvaluationScore[]

  @@index([category])
  @@index([isActive])
  @@index([order])
}

model ReviewerAssignment {
  id              String   @id @default(cuid())
  applicationId   String
  reviewerId      String   // User ID of the reviewer
  stage           ReviewStage @default(SCREENING)
  priority        Int      @default(0) // Higher priority = more urgent
  assignedAt      DateTime @default(now())
  dueDate         DateTime?
  completedAt     DateTime?
  notes           String?  // Assignment notes or instructions
  
  // Relations
  application     Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  reviewer        User        @relation("ReviewerAssignments", fields: [reviewerId], references: [id], onDelete: Cascade)
  evaluations     ApplicationEvaluation[]

  @@unique([applicationId, reviewerId, stage]) // One assignment per reviewer per stage
  @@index([reviewerId])
  @@index([stage])
  @@index([priority])
  @@index([dueDate])
}

model ApplicationEvaluation {
  id                  String          @id @default(cuid())
  applicationId       String
  reviewerId          String          // User ID of the reviewer
  assignmentId        String          // Links to ReviewerAssignment
  status              EvaluationStatus @default(PENDING)
  stage               ReviewStage
  overallScore        Float?          // Calculated weighted average
  overallComments     String?         @db.Text // General comments about the application
  recommendation      String?         // ACCEPT, REJECT, WAITLIST, NEEDS_MORE_INFO
  confidence          Int?            // Reviewer confidence level (1-5)
  timeSpentMinutes    Int?            // Time spent on evaluation
  
  // Video-specific fields
  videoWatched        Boolean         @default(false)
  videoTimestamp      String?         // JSON array of timestamp notes
  videoQuality        Int?            // Video quality rating (1-5)
  
  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt
  completedAt         DateTime?

  // Relations
  application         Application            @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  reviewer            User                   @relation("ApplicationEvaluations", fields: [reviewerId], references: [id], onDelete: Cascade)
  assignment          ReviewerAssignment     @relation(fields: [assignmentId], references: [id], onDelete: Cascade)
  scores              EvaluationScore[]
  comments            EvaluationComment[]

  @@unique([applicationId, reviewerId, stage]) // One evaluation per reviewer per stage
  @@index([reviewerId])
  @@index([status])
  @@index([stage])
  @@index([overallScore])
  @@index([recommendation])
}

model EvaluationScore {
  id            String    @id @default(cuid())
  evaluationId  String
  criteriaId    String
  score         Float     // The actual score given
  reasoning     String?   @db.Text // Explanation for the score
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  evaluation    ApplicationEvaluation @relation(fields: [evaluationId], references: [id], onDelete: Cascade)
  criteria      EvaluationCriteria    @relation(fields: [criteriaId], references: [id], onDelete: Cascade)

  @@unique([evaluationId, criteriaId]) // One score per criteria per evaluation
  @@index([score])
}

model EvaluationComment {
  id            String    @id @default(cuid())
  evaluationId  String
  questionKey   String?   // Which application question this relates to
  comment       String    @db.Text
  isPrivate     Boolean   @default(true) // Private to reviewers or shared with applicant
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  evaluation    ApplicationEvaluation @relation(fields: [evaluationId], references: [id], onDelete: Cascade)

  @@index([evaluationId])
  @@index([questionKey])
}

model ReviewConsensus {
  id              String    @id @default(cuid())
  applicationId   String    @unique // One consensus per application
  finalDecision   String?   // ACCEPT, REJECT, WAITLIST
  consensusScore  Float?    // Aggregate consensus score
  discussionNotes String?   @db.Text // Notes from consensus discussion
  decidedBy       String?   // Final decision maker (User ID)
  decidedAt       DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relations
  application     Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  decisionMaker   User?       @relation("ConsensusDecisions", fields: [decidedBy], references: [id])

  @@index([finalDecision])
  @@index([consensusScore])
}

// Reviewer Competency System for Weighted Scoring
model ReviewerCompetency {
  id              String          @id @default(cuid())
  reviewerId      String          // User ID of the reviewer
  category        CriteriaCategory // Which evaluation category this competency applies to
  competencyLevel Int             @default(3) // 1-5 scale (1=Novice, 3=Competent, 5=Expert)
  baseWeight      Float           @default(1.0) // Optional manual weight override
  notes           String?         // Admin notes about this competency rating
  assignedBy      String?         // Who assigned this competency (User ID)
  assignedAt      DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  // Relations
  reviewer        User            @relation("ReviewerCompetencies", fields: [reviewerId], references: [id], onDelete: Cascade)
  assignedByUser  User?           @relation("AssignedCompetencies", fields: [assignedBy], references: [id])

  @@unique([reviewerId, category]) // One competency per reviewer per category
  @@index([reviewerId])
  @@index([category])
  @@index([competencyLevel])
}

// Profile System Models
model UserProfile {
  id                    String   @id @default(cuid())
  userId                String   @unique
  bio                   String?  @db.Text
  jobTitle              String?
  company               String?
  location              String?
  website               String?
  githubUrl             String?
  linkedinUrl           String?
  twitterUrl            String?
  skills                String[] // Array of skill tags (legacy, use UserSkills for new data)
  interests             String[] // Array of interest areas

  // Skills migration metadata
  priorExperience       String?  @db.Text  // Rich experience descriptions from applications
  skillsSource          String?  @default("manual") // "application" | "manual" | "imported"
  skillsSyncedAt        DateTime? // When skills were last synced from application

  availableForMentoring Boolean  @default(false)
  availableForHiring    Boolean  @default(false)
  availableForOfficeHours Boolean @default(false)
  isPublic              Boolean  @default(true) // If false, profile is hidden from non-logged-in users
  timezone              String?
  languages             String[] // Spoken languages
  yearsOfExperience     Int?
  
  // Profile image
  avatarUrl             String?  // Custom uploaded avatar URL
  
  // Additional contact methods
  telegramHandle        String?
  telegramChatId        String?  // Telegram chat ID for bot DMs (captured from bot interactions)
  discordHandle         String?
  phoneNumber           String?
  
  // Mentor-specific fields
  mentorshipStyle       String?    @db.Text  // How they approach mentoring
  previousMentoringExp  String?    @db.Text  // Previous mentoring experience
  mentorSpecializations String[]             // Specific areas they want to mentor on
  mentorGoals          String?    @db.Text  // Goals for mentoring
  mentorAvailableDates String[]             // Available time periods
  mentorHoursPerWeek   String?             // Time commitment
  mentorPreferredContact String?           // Preferred contact method

  // Speaker-specific fields
  speakerTalkTitle      String?             // Proposed talk title
  speakerTalkAbstract   String?    @db.Text // Talk abstract/description
  speakerTalkFormat     String?             // keynote, panel, workshop, lightning, etc.
  speakerTalkDuration   String?             // Preferred duration
  speakerTalkTopic      String?             // Topic or track
  speakerPreviousExperience String? @db.Text // Previous speaking experience
  speakerPastTalkUrl    String?             // Link to past talk recording

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  // Relations
  user                  User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  projects              UserProject[]
  
  @@index([location])
  @@index([availableForMentoring])
  @@index([availableForHiring])
  @@index([availableForOfficeHours])
}

model UserProject {
  id            String      @id @default(cuid())
  profileId     String
  title         String
  description   String?     @db.Text
  githubUrl     String?     // Legacy: Single GitHub URL (kept for backward compatibility)
  liveUrl       String?
  imageUrl      String?     // Project logo (small icon/thumbnail)
  bannerUrl     String?     // Project banner (large header image)
  technologies  String[]    // Tech stack used
  focusAreas    String[]    // Focus areas/categories (e.g., "AI", "Privacy", "Trust Networks")
  featured      Boolean     @default(false)
  order         Int         @default(0)

  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  // Relations
  profile       UserProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)
  repositories  Repository[] // Project repositories (supports multiple repos)
  updates       ProjectUpdate[] // Project timeline updates
  collaborators ProjectCollaborator[] // Users who can collaborate on this project
  likes         UserProjectLike[] // Users who liked this project
  metrics       ProjectMetric[]     // Metrics tracked for this project
  measurements  MetricMeasurement[] // Measurements for this project

  @@index([profileId])
  @@index([featured])
}

model Repository {
  id          String      @id @default(cuid())
  url         String      // GitHub repository URL
  name        String?     // Repository name (e.g., "frontend", "backend", "core")
  description String?     // Optional description of this repository's purpose
  isPrimary   Boolean     @default(false) // Mark main/primary repo
  order       Int         @default(0)     // Display order
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // GitHub Activity Tracking - Lifetime Metrics
  lastCommitDate    DateTime?
  firstCommitDate   DateTime?
  totalCommits      Int       @default(0)
  lastSyncedAt      DateTime?
  isActive          Boolean   @default(false) // Active if commit in last 30 days
  weeksActive       Float?    // Duration from first to last commit
  commitsData       Json?     // Full lifetime commit timeline

  // Relations
  project          UserProject @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId        String
  residencyMetrics RepositoryResidencyMetrics[]
  attestations     Attestation[]

  @@index([projectId])
  @@index([isPrimary])
  @@index([isActive])
}

// Junction table for tracking residency-specific GitHub metrics
// Allows projects to participate in multiple residencies over time
model RepositoryResidencyMetrics {
  id                String   @id @default(cuid())
  repositoryId      String
  eventId           String

  // Residency-specific metrics
  commitsData       Json?      // Commit timeline for THIS residency period
  residencyCommits  Int        @default(0)
  residencyStartDate DateTime?
  residencyEndDate  DateTime?
  lastSyncedAt      DateTime?

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  repository        Repository @relation(fields: [repositoryId], references: [id], onDelete: Cascade)
  event             Event @relation("RepositoryMetrics", fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([repositoryId, eventId])
  @@index([repositoryId])
  @@index([eventId])
}

// EAS (Ethereum Attestation Service) attestations for repository activity
// Each attestation is an on-chain record of GitHub metrics at a point in time
model Attestation {
  id            String   @id @default(cuid())
  uid           String   @unique  // EAS attestation UID (on-chain identifier)
  repositoryId  String
  schemaId      String             // EAS schema ID used for this attestation
  chain         String   @default("optimism")
  data          Json               // Attestation payload (metrics snapshot)
  snapshotDate  DateTime           // When the source data was captured
  isRetroactive Boolean  @default(false)  // True for historical BA attestations
  createdAt     DateTime @default(now())

  // Relations
  repository    Repository @relation(fields: [repositoryId], references: [id], onDelete: Cascade)

  @@index([repositoryId])
  @@index([uid])
}

model ProjectCollaborator {
  id          String   @id @default(cuid())
  projectId   String   // UserProject ID
  userId      String   // Collaborator's User ID
  role        String   @default("member") // "member" for now, can add "viewer" later
  canEdit     Boolean  @default(true)
  addedAt     DateTime @default(now())

  // Relations
  project     UserProject @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user        User        @relation("ProjectCollaborations", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([projectId, userId]) // Prevent duplicate collaborators
  @@index([projectId])
  @@index([userId])
}

model ProjectUpdate {
  id            String      @id @default(cuid())
  projectId     String      // Links to UserProject
  userId        String      // User who created the update
  title         String      // Update title/milestone
  content       String      @db.Text // Update content (markdown supported)
  weekNumber    Int?        // Which week of the program (optional)
  updateDate    DateTime    @default(now()) // Date the update occurred (can be backdated)
  imageUrls     String[]    // Progress screenshots
  githubUrls    String[]    // Links to relevant commits/PRs
  demoUrls      String[]    // Links to demos/prototypes
  tags          String[]    // Tags for categorization (e.g., "milestone", "challenge", "demo")

  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  // Relations
  project       UserProject @relation(fields: [projectId], references: [id], onDelete: Cascade)
  author        User        @relation("ProjectUpdates", fields: [userId], references: [id], onDelete: Cascade)
  likes         ProjectUpdateLike[] // Users who liked this update
  comments      ProjectUpdateComment[] // Comments on this update

  @@index([projectId])
  @@index([userId])
  @@index([weekNumber])
  @@index([updateDate])
  @@index([createdAt])
}

// Likes on project updates (local + optional Bluesky sync)
model ProjectUpdateLike {
  id              String        @id @default(cuid())
  projectUpdateId String        // Which update was liked
  userId          String        // Who liked it
  blueskyUri      String?       // AT Proto URI if synced to Bluesky (future)

  // Kudos transfer system
  kudosTransferred Float?       // Amount of kudos transferred with this like (2% of liker's kudos)
  likerKudosAtTime Float?       // Liker's total kudos balance when they liked

  createdAt       DateTime      @default(now())

  // Relations
  projectUpdate   ProjectUpdate @relation(fields: [projectUpdateId], references: [id], onDelete: Cascade)
  user            User          @relation("ProjectUpdateLikes", fields: [userId], references: [id], onDelete: Cascade)

  // Ensure each user can only like an update once
  @@unique([projectUpdateId, userId])
  @@index([projectUpdateId])
  @@index([userId])
  @@index([createdAt])
}

// Likes on user projects
model UserProjectLike {
  id        String      @id @default(cuid())
  projectId String      // Which UserProject was liked
  userId    String      // Who liked it

  // Kudos transfer system
  kudosTransferred Float?  // Amount of kudos transferred with this like (2% of liker's kudos)
  likerKudosAtTime Float?  // Liker's total kudos balance when they liked

  createdAt DateTime    @default(now())

  // Relations
  project   UserProject @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user      User        @relation("UserProjectLikes", fields: [userId], references: [id], onDelete: Cascade)

  // Ensure each user can only like a project once
  @@unique([projectId, userId])
  @@index([projectId])
  @@index([userId])
  @@index([createdAt])
}

// Comments on project updates
model ProjectUpdateComment {
  id              String        @id @default(cuid())
  projectUpdateId String        // Which update was commented on
  userId          String        // Who made the comment
  content         String        @db.Text // Comment content (markdown supported)

  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relations
  projectUpdate   ProjectUpdate @relation(fields: [projectUpdateId], references: [id], onDelete: Cascade)
  user            User          @relation("ProjectUpdateComments", fields: [userId], references: [id], onDelete: Cascade)
  likes           ProjectUpdateCommentLike[]

  @@index([projectUpdateId])
  @@index([userId])
  @@index([createdAt])
}

// Likes on project update comments
model ProjectUpdateCommentLike {
  id        String   @id @default(cuid())
  commentId String   // Which comment was liked
  userId    String   // Who liked it

  // Kudos transfer system
  kudosTransferred Float? // Amount of kudos transferred with this like (2% of liker's kudos)
  likerKudosAtTime Float? // Liker's total kudos balance when they liked

  createdAt DateTime @default(now())

  comment ProjectUpdateComment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user    User                 @relation("ProjectUpdateCommentLikes", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([commentId, userId])
  @@index([commentId])
  @@index([userId])
  @@index([createdAt])
}

// Asks and Offers for event participants
enum AskOfferType {
  ASK    // Looking for help/resources
  OFFER  // Offering help/resources
}

model AskOffer {
  id            String        @id @default(cuid())
  userId        String        // User who created the ask/offer
  eventId       String?       // Event this ask/offer is for (optional - can be community-wide)
  type          AskOfferType  // ASK or OFFER
  title         String        // Short title (e.g., "Looking for Solidity mentor")
  description   String        @db.Text // Detailed description
  tags          String[]      // Tags for categorization (e.g., ["mentorship", "technical"])
  isActive      Boolean       @default(true) // Can be marked as fulfilled/closed
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  // Relations
  user          User          @relation("UserAsksOffers", fields: [userId], references: [id], onDelete: Cascade)
  event         Event?        @relation("EventAsksOffers", fields: [eventId], references: [id], onDelete: Cascade)
  likes         AskOfferLike[]
  comments      AskOfferComment[] @relation("AskOfferComments")

  @@index([userId])
  @@index([eventId])
  @@index([type])
  @@index([isActive])
  @@index([createdAt])
}

model AskOfferLike {
  id          String    @id @default(cuid())
  askOfferId  String    // Which ask/offer was liked
  userId      String    // Who liked it

  // Kudos transfer system
  kudosTransferred Float?  // Amount of kudos transferred with this like (2% of liker's kudos)
  likerKudosAtTime Float?  // Liker's total kudos balance when they liked

  createdAt   DateTime  @default(now())

  askOffer    AskOffer  @relation(fields: [askOfferId], references: [id], onDelete: Cascade)
  user        User      @relation("AskOfferLikes", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([askOfferId, userId])
  @@index([askOfferId])
  @@index([userId])
  @@index([createdAt])
}

// Ask/Offer Comment System
model AskOfferComment {
  id          String   @id @default(cuid())
  askOfferId  String
  userId      String
  parentId    String?  // For nested replies
  content     String   @db.Text
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  askOffer    AskOffer           @relation("AskOfferComments", fields: [askOfferId], references: [id], onDelete: Cascade)
  user        User               @relation("UserAskOfferComments", fields: [userId], references: [id], onDelete: Cascade)
  parent      AskOfferComment?   @relation("AskOfferCommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies     AskOfferComment[]  @relation("AskOfferCommentReplies")
  likes       AskOfferCommentLike[]

  @@index([askOfferId])
  @@index([userId])
  @@index([parentId])
  @@index([createdAt])
}

model AskOfferCommentLike {
  id               String   @id @default(cuid())
  commentId        String
  userId           String
  kudosTransferred Float?   // Amount of kudos transferred (2% of liker's kudos)
  likerKudosAtTime Float?   // Liker's total kudos balance when they liked
  createdAt        DateTime @default(now())

  // Relations
  comment AskOfferComment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user    User            @relation("AskOfferCommentLikes", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([commentId, userId])
  @@index([commentId])
  @@index([userId])
  @@index([createdAt])
}

model ProfileSync {
  id            String   @id @default(cuid())
  userId        String
  applicationId String
  syncedFields  String[] // Which fields were copied (e.g., ["skills", "bio", "location"])
  syncedAt      DateTime @default(now())

  // Relations
  user         User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  application  Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)

  @@unique([userId, applicationId]) // Prevent duplicate syncs per application
  @@index([userId])
  @@index([applicationId])
  @@index([syncedAt])
}

// Onboarding System Enums
enum DietType {
  OMNIVORE
  VEGETARIAN
  VEGAN
  OTHER
}

enum MentoringOpenness {
  YES
  NO
  MAYBE
}

// Onboarding System Models
model ApplicationOnboarding {
  id                      String   @id @default(cuid())
  applicationId           String   @unique // One onboarding per application
  
  // Contact & Logistics
  bloodType               String?  // Blood type
  emergencyContactName    String?  // Emergency contact name
  emergencyContactRelationship String? // Emergency contact relationship
  emergencyContactPhone   String?  // Emergency contact phone/WhatsApp
  arrivalDateTime         DateTime? // Arrival date and time in Buenos Aires
  departureDateTime       DateTime? // Departure date and time
  
  // Travel Documents - DEPRECATED: These fields were removed from the onboarding form but kept for existing data
  eTicketUrl              String?  // URL to uploaded e-ticket file (deprecated)
  eTicketFileName         String?  // Original filename (deprecated)
  healthInsuranceUrl      String?  // URL to uploaded insurance proof (deprecated)
  healthInsuranceFileName String?  // Original filename (deprecated)
  
  // Food & Dietary Needs
  dietType                DietType? // Diet type (omnivore, vegetarian, vegan, other)
  dietTypeOther           String?   // If diet type is "other", specify
  allergiesIntolerances   String?   @db.Text // Allergies or intolerances
  dietaryRequirements     String?   @db.Text // Legacy field, keeping for backward compatibility
  
  // English Proficiency
  englishProficiencyLevel Int?     // English proficiency level (0-100)
  
  // Knowledge Sharing, Community & Mentorship
  primaryGoals            String?  @db.Text // Primary goals for participating
  skillsToGain            String?  @db.Text // Skills or knowledge to gain
  openToMentoring         MentoringOpenness? // Open to mentoring others
  mentorsToLearnFrom      String?  @db.Text // Mentors they'd love to learn from
  organizationsToConnect  String?  @db.Text // Organizations to connect with
  
  // Technical Workshop
  technicalWorkshopTitle  String?  // Technical workshop title
  technicalWorkshopDescription String? @db.Text // Technical workshop description
  technicalWorkshopDuration String? // Technical workshop duration
  technicalWorkshopMaterials String? @db.Text // Technical workshop materials needed
  
  // Beyond Work Activities
  beyondWorkInterests     String?  @db.Text // Other interests or skills to share
  beyondWorkTitle         String?  // Beyond work workshop title
  beyondWorkDescription   String?  @db.Text // Beyond work workshop description
  beyondWorkDuration      String?  // Beyond work workshop duration
  beyondWorkMaterials     String?  @db.Text // Beyond work workshop materials needed
  
  // Media & Bio
  headshotUrl             String?  // URL to uploaded headshot
  headshotFileName        String?  // Original headshot filename
  shortBio                String?  @db.Text // Short bio or description
  
  // Commitments & Confirmations
  participateExperiments  Boolean  @default(false)
  mintHypercert          Boolean  @default(false)
  interestedIncubation   Boolean  @default(false)
  interestedEIR          Boolean  @default(false) // Interested in Entrepreneur in Residency program
  liabilityWaiverConsent  Boolean  @default(false) // Liability waiver consent
  codeOfConductAgreement  Boolean  @default(false) // Code of conduct agreement
  communityActivitiesConsent Boolean @default(false) // Community activities participation
  
  // Additional Information
  additionalComments     String?  @db.Text
  
  // Metadata
  completed              Boolean  @default(false)
  submittedAt            DateTime?
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt
  
  // Relations
  application            Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  
  @@index([applicationId])
  @@index([completed])
  @@index([submittedAt])
}

// Telegram Authentication System
model TelegramAuth {
  id                String   @id @default(cuid())
  userId            String   @unique
  encryptedApiId    String   // Encrypted API ID (user-specific)
  encryptedApiHash  String   // Encrypted API hash (user-specific)
  encryptedSession  String   @db.Text // Encrypted session string
  salt              String   // For key derivation
  iv                String   // Initialization vector for encryption
  expiresAt         DateTime // Session expiration
  isActive          Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([expiresAt])
  @@index([isActive])
}

// Temporary authentication sessions (survives server restarts)
model TelegramAuthSession {
  id              String    @id @default(cuid())
  sessionId       String    @unique // User-generated session ID
  userId          String
  phoneCodeHash   String?   // Telegram phone code hash
  apiId           String?   // User's API ID
  apiHash         String?   // User's API Hash  
  clientData      String?   @db.Text // Serialized client session data
  expiresAt       DateTime  // Session expiration (10 minutes)
  createdAt       DateTime  @default(now())
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([sessionId])
  @@index([userId])
  @@index([expiresAt])
}

// Skills System Models
model Skills {
  id          String   @id @default(cuid())
  name        String   @unique // Skill name (e.g., "React", "Solidity", "Product Management")
  category    String?  // Optional category (e.g., "Frontend", "Backend", "Design", "Blockchain")
  popularity  Int      @default(0) // For sorting suggestions by popularity
  isActive    Boolean  @default(true) // For soft deletion
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  userSkills  UserSkills[]
  
  @@index([category])
  @@index([popularity])
  @@index([isActive])
  @@index([name])
}

model UserSkills {
  id              String   @id @default(cuid())
  userId          String   // User who has this skill
  skillId         String   // Reference to Skills table
  experienceLevel Int?     // Optional 1-10 experience level
  createdAt       DateTime @default(now())
  
  // Relations
  user            User     @relation("UserSkills", fields: [userId], references: [id], onDelete: Cascade)
  skill           Skills   @relation(fields: [skillId], references: [id], onDelete: Cascade)
  
  @@unique([userId, skillId]) // Prevent duplicate skills per user
  @@index([userId])
  @@index([skillId])
  @@index([experienceLevel])
}

// Analytics System Models
enum AnalyticsEndpoint {
  APPLICATION_TEXT_CORPUS
  DEMOGRAPHICS_BREAKDOWN  
  SKILLS_WORD_CLOUD
  APPLICATION_TIMELINE
  REVIEW_METRICS
}

model AnalyticsAudit {
  id            String            @id @default(cuid())
  userId        String            // User who made the request
  endpoint      AnalyticsEndpoint // Which analytics endpoint was accessed
  eventId       String?           // Event context (if applicable)
  dataRequested String?           // Additional context about what data was requested
  requestParams Json?             // JSON of request parameters for debugging
  responseSize  Int?              // Size of response data (for monitoring)
  ipAddress     String?           // IP address for security monitoring
  userAgent     String?           // User agent for security monitoring
  createdAt     DateTime          @default(now())
  
  // Relations
  user          User              @relation("AnalyticsAudits", fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([endpoint])
  @@index([eventId])
  @@index([createdAt])
}

model AnalyticsRateLimit {
  id            String   @id @default(cuid())
  userId        String   // User being rate limited
  endpoint      AnalyticsEndpoint // Which endpoint
  requestCount  Int      @default(0) // Number of requests in current window
  windowStart   DateTime @default(now()) // Start of current rate limit window
  lastRequest   DateTime @default(now()) // Last request timestamp
  isBlocked     Boolean  @default(false) // Whether user is currently blocked

  // Relations
  user          User     @relation("AnalyticsRateLimits", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, endpoint]) // One rate limit record per user per endpoint
  @@index([userId])
  @@index([endpoint])
  @@index([windowStart])
  @@index([isBlocked])
}

// Praise System Models
model Praise {
  id            String   @id @default(cuid())

  // Sender (who sent the praise)
  senderId      String   // User who sent the praise
  senderTelegramId BigInt? // Telegram ID for verification

  // Recipient (who received the praise)
  recipientId   String?  // User being praised (nullable if we can't match)
  recipientName String   // @username from the message

  // Praise content
  message       String   @db.Text // The praise message
  category      String?  // Optional: auto-tag (e.g., "talk", "help", "mentorship")

  // Kudos transfer system
  kudosTransferred Float?  // Amount of kudos transferred with this praise (5% of sender's kudos)
  senderKudosAtTime Float? // Sender's total kudos balance when they praised

  // Context
  eventId       String?  // Optional: link to specific event
  telegramMsgId String?  // Original Telegram message ID

  // Channel cross-posting
  channelMessageId String?  // Message ID if cross-posted to Telegram channel
  crossPostedAt    DateTime? // When it was cross-posted to channel

  // Metadata
  createdAt     DateTime @default(now())
  isPublic      Boolean  @default(false) // Can be shared publicly

  // Relations
  sender        User     @relation("PraiseSent", fields: [senderId], references: [id], onDelete: Cascade)
  recipient     User?    @relation("PraiseReceived", fields: [recipientId], references: [id], onDelete: Cascade)
  event         Event?   @relation("EventPraises", fields: [eventId], references: [id])

  @@index([senderId])
  @@index([recipientId])
  @@index([eventId])
  @@index([createdAt])
}

// Metrics System Models
enum MetricType {
  BUILDER           // Builder-focused metrics
  ENVIRONMENTAL     // Environmental/social good metrics
  GIT               // Git/repository metrics
  ONCHAIN          // On-chain metrics
  OFFCHAIN         // Off-chain metrics
  CUSTOM           // Custom evaluation metrics
}

enum CollectionMethod {
  ONCHAIN          // Collected from blockchain
  OFFCHAIN_API     // Off-chain API calls
  SELF_REPORTING   // Self-reported by users
  MANUAL           // Manually collected
  AUTOMATED        // Automated collection
}

enum MetricCadence {
  REALTIME         // Real-time updates
  DAILY            // Daily updates
  WEEKLY           // Weekly updates
  MONTHLY          // Monthly updates
  QUARTERLY        // Quarterly updates
  ANNUAL           // Annual updates
  ONE_TIME         // One-time collection
  CUSTOM           // Custom cadence
}

enum MetricTimePeriod {
  BEFORE           // Before event
  DURING           // During event
  AFTER            // After event
  ONGOING          // Ongoing tracking
}

model Metric {
  id                    String            @id @default(cuid())

  // Core identification
  name                  String            // Metric name (e.g., "Ad-driven platforms' advertiser turn-over rate")
  slug                  String?           @unique // URL-safe version for routing
  description           String?           @db.Text // Detailed description

  // Metric type and categorization
  metricType            MetricType[]      // Multiple types possible (BUILDER, GIT, ONCHAIN, etc.)
  unitOfMetric          String?           // Unit of measurement (e.g., "USD", "count", "percentage")
  category              String?           // Additional categorization

  // Collection methodology
  collectionMethod      CollectionMethod
  cadence               MetricCadence     @default(ONE_TIME)
  timePeriod            MetricTimePeriod  @default(DURING)

  // Data sources and tracking
  isOnChain             Boolean           @default(false)
  deployerAccount       String?           // Deployer account if on-chain
  offChainApis          String[]          // Array of off-chain API sources
  gitMetric             Boolean           @default(false) // Is this a Git-based metric?
  dependencyTracking    Boolean           @default(false) // Tracks dependencies?

  // Evaluation methods
  attestationOriented   Boolean           @default(false)
  customEvaluation      Boolean           @default(false)
  selfReporting         Boolean           @default(false)
  hypercertsUsed        Boolean           @default(false) // Uses Hypercerts
  zkEmail               Boolean           @default(false) // Uses ZK Email

  // Project relationships
  allSoftwareProjects   Boolean           @default(false) // Applies to all software projects
  ftcProjects           String[]          // Array of FTC project identifiers
  projectIdNeeded       Boolean           @default(false) // Requires project ID for tracking

  // Impact focus areas
  environmentalSocialGood Boolean         @default(false)
  relevantToBBI         Boolean           @default(false) // Relevant to Builder-Based Infrastructure
  impactEvaluators      String[]          // Array of evaluator identifiers

  // Proof of concept and sources
  pocContact            String?           // Point of contact for POC
  source                String?           // Source of the metric definition
  notes                 String?           @db.Text // Additional notes and context

  // Measurement data
  quantity              Float?            // Actual measured quantity (if applicable)

  // Metadata
  isActive              Boolean           @default(true)
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  createdBy             String?           // User who created this metric

  // Relations
  creator               User?             @relation("MetricsCreated", fields: [createdBy], references: [id], onDelete: SetNull)
  measurements          MetricMeasurement[] // Historical measurements
  projectMetrics        ProjectMetric[]   // Link to specific UserProjects

  @@index([slug])
  @@index([collectionMethod])
  @@index([cadence])
  @@index([isOnChain])
  @@index([isActive])
  @@index([createdAt])
}

// Historical measurements for metrics
model MetricMeasurement {
  id              String    @id @default(cuid())
  metricId        String
  projectId       String?   // Optional: specific to a UserProject
  eventId         String?   // Optional: specific to an Event

  value           Float     // Measured value
  unitOfMetric    String    // Unit at time of measurement
  source          String?   // Data source for this measurement
  verificationUrl String?   // URL to verification (e.g., on-chain tx, API response)

  // Context
  measurementDate DateTime  // When the measurement was taken
  timePeriod      MetricTimePeriod // BEFORE, DURING, AFTER
  notes           String?   @db.Text

  // Metadata
  measuredBy      String?   // User who recorded this measurement
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relations
  metric          Metric    @relation(fields: [metricId], references: [id], onDelete: Cascade)
  project         UserProject? @relation(fields: [projectId], references: [id], onDelete: Cascade)
  event           Event?    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  measuredByUser  User?     @relation("MetricMeasurements", fields: [measuredBy], references: [id], onDelete: SetNull)

  @@index([metricId])
  @@index([projectId])
  @@index([eventId])
  @@index([measurementDate])
  @@index([timePeriod])
}

// Link metrics to specific projects
model ProjectMetric {
  id          String      @id @default(cuid())
  projectId   String      // UserProject ID
  metricId    String      // Metric ID
  isTracking  Boolean     @default(true) // Actively tracking this metric
  targetValue Float?      // Target/goal value for this metric
  addedAt     DateTime    @default(now())
  addedBy     String?     // User who added this metric

  // Relations
  project     UserProject @relation(fields: [projectId], references: [id], onDelete: Cascade)
  metric      Metric      @relation(fields: [metricId], references: [id], onDelete: Cascade)
  addedByUser User?       @relation("ProjectMetricsAdded", fields: [addedBy], references: [id], onDelete: SetNull)

  @@unique([projectId, metricId]) // Prevent duplicate metrics per project
  @@index([projectId])
  @@index([metricId])
  @@index([isTracking])
}

// AT Proto (Bluesky/Custom PDS) Integration
model AtProtoAccount {
  id          String   @id @default(cuid())
  userId      String   @unique // One AT Proto account per user

  // Identity
  handle      String   // user.bsky.social or user.custom-pds.com
  did         String   @unique // Decentralized identifier (did:plc:xxx)
  pdsUrl      String   // PDS server URL (e.g., https://bsky.social or custom PDS)

  // Encrypted session credentials (stored server-side only)
  accessJwt   String?  @db.Text // Encrypted access token
  refreshJwt  String?  @db.Text // Encrypted refresh token

  // Metadata
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  lastUsedAt  DateTime @default(now()) // Track last time credentials were used

  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([did])
  @@index([handle])
}

// Wallet Address System
enum WalletChain {
  ETHEREUM
  POLYGON
  ARBITRUM
  OPTIMISM
  BASE
  SOLANA
  COSMOS
  OTHER
}

model WalletAddress {
  id          String      @id @default(cuid())
  userId      String      // User who owns this wallet
  address     String      // Wallet address (e.g., 0x... or solana address)
  chain       WalletChain @default(ETHEREUM) // Which blockchain
  label       String?     // Optional label (e.g., "Main Wallet", "Governance")
  isPrimary   Boolean     @default(false) // Mark as primary wallet
  isVerified  Boolean     @default(false) // Whether ownership has been verified
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // Relations
  user        User        @relation("UserWalletAddresses", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, address, chain]) // Prevent duplicate address per user per chain
  @@index([userId])
  @@index([address])
  @@index([chain])
  @@index([isPrimary])
}

// Forum System Models
model ForumThread {
  id          String   @id @default(cuid())
  userId      String   // User who created the thread
  title       String   // Thread title
  content     String   @db.Text // Markdown content
  tags        String[] // Tags for categorization
  isActive    Boolean  @default(true) // Can be archived/hidden
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  user        User             @relation("UserForumThreads", fields: [userId], references: [id], onDelete: Cascade)
  comments    ForumComment[]
  likes       ForumThreadLike[]

  @@index([userId])
  @@index([isActive])
  @@index([createdAt])
}

model ForumComment {
  id          String   @id @default(cuid())
  threadId    String   // Thread this comment belongs to
  userId      String   // User who created the comment
  parentId    String?  // Parent comment for nested replies
  content     String   @db.Text // Markdown content
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  thread      ForumThread        @relation(fields: [threadId], references: [id], onDelete: Cascade)
  user        User               @relation("UserForumComments", fields: [userId], references: [id], onDelete: Cascade)
  parent      ForumComment?      @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies     ForumComment[]     @relation("CommentReplies")
  likes       ForumCommentLike[]

  @@index([threadId])
  @@index([userId])
  @@index([parentId])
  @@index([createdAt])
}

model ForumThreadLike {
  id               String   @id @default(cuid())
  threadId         String   // Thread being liked
  userId           String   // User who liked

  // Kudos transfer system
  kudosTransferred Float?   // Amount of kudos transferred (2% of liker's kudos)
  likerKudosAtTime Float?   // Liker's total kudos balance when they liked

  createdAt        DateTime @default(now())

  // Relations
  thread    ForumThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  user      User        @relation("ForumThreadLikes", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([threadId, userId])
  @@index([threadId])
  @@index([userId])
  @@index([createdAt])
}

model ForumCommentLike {
  id               String   @id @default(cuid())
  commentId        String   // Comment being liked
  userId           String   // User who liked

  // Kudos transfer system
  kudosTransferred Float?   // Amount of kudos transferred (2% of liker's kudos)
  likerKudosAtTime Float?   // Liker's total kudos balance when they liked

  createdAt        DateTime @default(now())

  // Relations
  comment   ForumComment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user      User         @relation("ForumCommentLikes", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([commentId, userId])
  @@index([commentId])
  @@index([userId])
  @@index([createdAt])
}

// Schedule System Models

model ScheduleVenue {
  id          String   @id @default(cuid())
  eventId     String
  name        String
  description String?  @db.Text
  capacity    Int?
  order       Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  event        Event              @relation(fields: [eventId], references: [id], onDelete: Cascade)
  sessions     ScheduleSession[]
  owners       VenueOwner[]
  invitations  Invitation[]
  applications ApplicationVenue[]

  @@unique([eventId, name])
  @@index([eventId])
  @@index([order])
}

model ScheduleSessionType {
  id          String   @id @default(cuid())
  eventId     String
  name        String
  color       String   @default("#4299e1")
  order       Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  event       Event            @relation(fields: [eventId], references: [id], onDelete: Cascade)
  sessions    ScheduleSession[]

  @@unique([eventId, name])
  @@index([eventId])
  @@index([order])
}

model ScheduleTrack {
  id        String   @id @default(cuid())
  eventId   String
  name      String
  color     String   @default("#8b5cf6")
  order     Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  event    Event              @relation(fields: [eventId], references: [id], onDelete: Cascade)
  sessions ScheduleSession[]

  @@unique([eventId, name])
  @@index([eventId])
  @@index([order])
}

model ScheduleSession {
  id            String   @id @default(cuid())
  eventId       String
  title         String
  description   String?  @db.Text
  startTime     DateTime
  endTime       DateTime
  speakers      String[]
  venueId       String?
  sessionTypeId String?
  trackId       String?
  order         Int      @default(0)
  isPublished   Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  event           Event                @relation(fields: [eventId], references: [id], onDelete: Cascade)
  venue           ScheduleVenue?       @relation(fields: [venueId], references: [id], onDelete: SetNull)
  sessionType     ScheduleSessionType? @relation(fields: [sessionTypeId], references: [id], onDelete: SetNull)
  track           ScheduleTrack?       @relation(fields: [trackId], references: [id], onDelete: SetNull)
  sessionSpeakers SessionSpeaker[]

  @@index([eventId])
  @@index([startTime])
  @@index([venueId])
  @@index([sessionTypeId])
  @@index([trackId])
  @@index([isPublished])
}

model SessionSpeaker {
  id        String   @id @default(cuid())
  sessionId String
  userId    String
  role      String   @default("Speaker")
  order     Int      @default(0)
  createdAt DateTime @default(now())

  session   ScheduleSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  user      User            @relation("SessionSpeakers", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([sessionId, userId])
  @@index([sessionId])
  @@index([userId])
}

model VenueOwner {
  id         String   @id @default(cuid())
  userId     String
  venueId    String
  eventId    String   // Denormalized for efficient queries
  assignedBy String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user       User          @relation("VenueOwners", fields: [userId], references: [id], onDelete: Cascade)
  venue      ScheduleVenue @relation(fields: [venueId], references: [id], onDelete: Cascade)
  event      Event         @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([userId, venueId])
  @@index([userId, eventId])
  @@index([venueId])
  @@index([eventId])
}