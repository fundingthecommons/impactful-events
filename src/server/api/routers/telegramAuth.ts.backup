import { z } from "zod";
import { TRPCError } from "@trpc/server";
import { TelegramClient, sessions } from "telegram";
import { createTRPCRouter, protectedProcedure } from "~/server/api/trpc";
import { 
  encryptTelegramCredentials, 
  decryptTelegramCredentials,
  getSessionExpiration,
  isSessionExpired,
  hashForAudit,
  type TelegramCredentials 
} from "~/server/utils/encryption";
import { checkTelegramAuthRateLimit } from "~/server/utils/telegramCleanup";

// Note: Auth sessions now stored in database for persistence across server restarts
// Clean up expired auth sessions every 5 minutes
import { db } from "~/server/db";

// Database cleanup function using global db instance
const cleanupExpiredSessions = async () => {
  const now = new Date();
  try {
    await db.telegramAuthSession.deleteMany({
      where: {
        expiresAt: {
          lt: now,
        },
      },
    });
  } catch (error) {
    console.error("Failed to cleanup expired Telegram auth sessions:", error);
  }
};

// Clean up expired auth sessions every 5 minutes
setInterval(() => void cleanupExpiredSessions(), 5 * 60 * 1000);

interface TelegramClientInterface {
  connect: () => Promise<void>;
  start: (options: {
    phoneNumber: () => Promise<string>;
    password: () => Promise<string>;
    phoneCode: () => Promise<string>;
    onError: (err: unknown) => void;
  }) => Promise<void>;
  sendCode: (config: {apiId: number, apiHash: string}, phone: string) => Promise<{phone_code_hash: string, type?: {_: string}}>;
  signIn: (phone: string, phoneCode: string, phoneCodeHash: string) => Promise<void>;
  checkPassword: (password: string) => Promise<void>;
  session: { save: () => string };
  disconnect: () => Promise<void>;
}

export const telegramAuthRouter = createTRPCRouter({
  // Get current authentication status
  getAuthStatus: protectedProcedure.query(async ({ ctx }) => {
    const auth = await ctx.db.telegramAuth.findUnique({
      where: { userId: ctx.session.user.id },
      select: {
        isActive: true,
        expiresAt: true,
        createdAt: true,
        updatedAt: true,
      },
    });

    if (!auth) {
      return { isAuthenticated: false };
    }

    const expired = isSessionExpired(auth.expiresAt);
    if (expired) {
      // Mark as inactive if expired
      await ctx.db.telegramAuth.update({
        where: { userId: ctx.session.user.id },
        data: { isActive: false },
      });
      return { isAuthenticated: false };
    }

    return {
      isAuthenticated: auth.isActive,
      expiresAt: auth.expiresAt,
      createdAt: auth.createdAt,
      updatedAt: auth.updatedAt,
    };
  }),

  // Start the authentication process
  startAuth: protectedProcedure.mutation(async ({ ctx }) => {
    // Debug context
    console.log('Context debug:', {
      hasDb: !!ctx.db,
      hasSession: !!ctx.session,
      userId: ctx.session?.user?.id,
      dbType: typeof ctx.db
    });
    
    // Check rate limiting
    const rateLimit = checkTelegramAuthRateLimit(ctx.session.user.id);
    if (!rateLimit.allowed) {
      const resetTimeMinutes = Math.ceil((rateLimit.resetTime - Date.now()) / (1000 * 60));
      throw new TRPCError({
        code: "TOO_MANY_REQUESTS",
        message: `Too many authentication attempts. Please try again in ${resetTimeMinutes} minutes.`,
      });
    }

    // No longer need global API credentials - users provide their own

    // Check if user already has active auth
    const existingAuth = await ctx.db.telegramAuth.findUnique({
      where: { userId: ctx.session.user.id },
    });

    if (existingAuth && existingAuth.isActive && !isSessionExpired(existingAuth.expiresAt)) {
      throw new TRPCError({
        code: "CONFLICT",
        message: "You already have an active Telegram authentication",
      });
    }

    // Generate session ID for this auth process
    const sessionId = `${ctx.session.user.id}_${Date.now()}`;
    
    // Store session info in database for 10 minutes
    const expiresAt = new Date(Date.now() + 10 * 60 * 1000);
    
    await ctx.db.telegramAuthSession.create({
      data: {
        sessionId,
        userId: ctx.session.user.id,
        expiresAt,
      },
    });

    console.log(`Started Telegram auth for user ${hashForAudit(ctx.session.user.id)} (${rateLimit.remainingAttempts} attempts remaining)`);

    return { sessionId };
  }),

  // Send phone verification code
  sendPhoneCode: protectedProcedure
    .input(z.object({
      sessionId: z.string(),
      phoneNumber: z.string().min(1),
      apiId: z.string().min(1),
      apiHash: z.string().min(1),
    }))
    .mutation(async ({ ctx, input }) => {
      const session = await ctx.db.telegramAuthSession.findUnique({
        where: { sessionId: input.sessionId },
      });
      
      if (!session || session.expiresAt < new Date()) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Authentication session expired. Please start over.",
        });
      }

      // Use user-provided credentials instead of environment variables
      const apiId = input.apiId;
      const apiHash = input.apiHash;

      try {
        const client = new TelegramClient(new sessions.StringSession(""), parseInt(apiId), apiHash, {}) as unknown as TelegramClientInterface;

        // Connect to Telegram
        await client.connect();

        // Send verification code
        const result = await client.sendCode({
          apiId: parseInt(apiId),
          apiHash: apiHash,
        }, input.phoneNumber);
        
        // Get client session string to store in database
        const clientSessionString = client.session.save();
        
        // Update session with phone code hash and client session
        await ctx.db.telegramAuthSession.update({
          where: { sessionId: input.sessionId },
          data: {
            phoneCodeHash: result.phone_code_hash,
            apiId: input.apiId,
            apiHash: input.apiHash,
            clientData: clientSessionString,
          },
        });
        
        // Disconnect the temporary client - we'll recreate it later
        await client.disconnect();

        console.log(`Sent verification code to ${hashForAudit(input.phoneNumber)} for user ${hashForAudit(ctx.session.user.id)}`);

        return { success: true };
      } catch (error) {
        console.error("Failed to send phone code:", error);
        
        // Clean up session on error
        try {
          await ctx.db.telegramAuthSession.delete({
            where: { sessionId: input.sessionId },
          });
        } catch (cleanupError) {
          console.error("Error during session cleanup:", cleanupError);
        }
        
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: `Failed to send verification code: ${error instanceof Error ? error.message : 'Unknown error'}`,
        });
      }
    }),

  // Verify code and complete authentication
  verifyAndStore: protectedProcedure
    .input(z.object({
      sessionId: z.string(),
      phoneNumber: z.string(),
      phoneCode: z.string(),
      password: z.string().optional(),
    }))
    .mutation(async ({ ctx, input }) => {
      const session = await ctx.db.telegramAuthSession.findUnique({
        where: { sessionId: input.sessionId },
      });
      
      // Debug logging
      console.log(`Verifying session ${input.sessionId}:`, {
        exists: !!session,
        expired: session ? session.expiresAt < new Date() : 'N/A',
        hasClientData: session ? !!session.clientData : 'N/A',
        hasPhoneCodeHash: session ? !!session.phoneCodeHash : 'N/A',
        hasApiId: session ? !!session.apiId : 'N/A',
        hasApiHash: session ? !!session.apiHash : 'N/A',
        timeToExpiry: session ? Math.round((session.expiresAt.getTime() - Date.now()) / 1000) : 'N/A'
      });
      
      if (!session || session.expiresAt < new Date() || !session.clientData || !session.phoneCodeHash || !session.apiId || !session.apiHash) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Authentication session expired or invalid. Please start over.",
        });
      }

      try {
        // Recreate client from stored session data
        const client = new TelegramClient(
          new sessions.StringSession(session.clientData), 
          parseInt(session.apiId), 
          session.apiHash, 
          {}
        ) as unknown as TelegramClientInterface;
        
        // Connect to Telegram
        await client.connect();

        // Sign in with phone code
        await client.signIn(input.phoneNumber, input.phoneCode, session.phoneCodeHash);

        // Handle 2FA if password provided
        if (input.password) {
          await client.checkPassword(input.password);
        }

        // Get session string
        const sessionString = client.session.save();

        // Encrypt credentials
        const credentials: TelegramCredentials = {
          apiId: session.apiId,
          apiHash: session.apiHash,
          sessionString,
        };

        const encrypted = encryptTelegramCredentials(credentials, ctx.session.user.id);

        // Store in database
        await ctx.db.telegramAuth.upsert({
          where: { userId: ctx.session.user.id },
          update: {
            encryptedApiId: encrypted.encryptedApiId,
            encryptedApiHash: encrypted.encryptedApiHash,
            encryptedSession: encrypted.encryptedSession,
            salt: encrypted.salt,
            iv: encrypted.iv,
            expiresAt: getSessionExpiration(),
            isActive: true,
            updatedAt: new Date(),
          },
          create: {
            userId: ctx.session.user.id,
            encryptedApiId: encrypted.encryptedApiId,
            encryptedApiHash: encrypted.encryptedApiHash,
            encryptedSession: encrypted.encryptedSession,
            salt: encrypted.salt,
            iv: encrypted.iv,
            expiresAt: getSessionExpiration(),
            isActive: true,
          },
        });

        // Clean up auth session
        await client.disconnect();
        await ctx.db.telegramAuthSession.delete({
          where: { sessionId: input.sessionId },
        });

        console.log(`Successfully authenticated Telegram for user ${hashForAudit(ctx.session.user.id)}`);

        return { success: true };
      } catch (error) {
        console.error("Telegram authentication failed:", error);
        
        // Clean up on failure
        try {
          await ctx.db.telegramAuthSession.delete({
            where: { sessionId: input.sessionId },
          });
        } catch (cleanupError) {
          console.error("Error during session cleanup:", cleanupError);
        }
        
        if (error instanceof Error && error.message.includes("SESSION_PASSWORD_NEEDED")) {
          throw new TRPCError({
            code: "PRECONDITION_FAILED",
            message: "Two-factor authentication password required",
          });
        }
        
        throw new TRPCError({
          code: "UNAUTHORIZED",
          message: `Authentication failed: ${error instanceof Error ? error.message : 'Invalid verification code'}`,
        });
      }
    }),

  // Remove stored authentication
  deleteAuth: protectedProcedure.mutation(async ({ ctx }) => {
    const deleted = await ctx.db.telegramAuth.delete({
      where: { userId: ctx.session.user.id },
    }).catch(() => null);

    if (deleted) {
      console.log(`Deleted Telegram auth for user ${hashForAudit(ctx.session.user.id)}`);
    }

    return { success: true };
  }),

  // Get decrypted credentials (for server-side use only)
  getCredentials: protectedProcedure.query(async ({ ctx }) => {
    const auth = await ctx.db.telegramAuth.findUnique({
      where: { userId: ctx.session.user.id },
    });

    if (!auth || !auth.isActive || isSessionExpired(auth.expiresAt)) {
      throw new TRPCError({
        code: "NOT_FOUND",
        message: "No active Telegram authentication found",
      });
    }

    try {
      const credentials = decryptTelegramCredentials({
        encryptedApiId: auth.encryptedApiId,
        encryptedApiHash: auth.encryptedApiHash,
        encryptedSession: auth.encryptedSession,
        salt: auth.salt,
        iv: auth.iv,
      }, ctx.session.user.id);

      return credentials;
    } catch (error) {
      console.error("Failed to decrypt Telegram credentials:", error instanceof Error ? error.message : String(error));
      throw new TRPCError({
        code: "INTERNAL_SERVER_ERROR",
        message: "Failed to decrypt stored credentials",
      });
    }
  }),
});